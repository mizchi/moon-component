// Generated by wit-bindgen-moonbit

///| Resource handle (i32 index into handle table)
pub(all) struct Blob(Int) derive(Show, Eq)

/// Export trait for blob-store
pub(open) trait Exports {
  blob_new(Self, data : Array[Byte]) -> Blob
  blob_size(Self, this : Blob) -> UInt
  blob_read(Self, this : Blob, offset : UInt, len : UInt) -> Array[Byte]
  blob_write(Self, this : Blob, offset : UInt, data : Array[Byte]) -> Unit
  create_blob(Self, data : Array[Byte]) -> Blob
  get_blob_size(Self, b : Blob) -> UInt
  consume_blob(Self, b : Blob) -> Array[Byte]
}

let exports_impl : Ref[&Exports?] = { val: None }

pub fn register(impl_ : &Exports) -> Unit {
  exports_impl.val = Some(impl_)
}

pub fn get_exports() -> &Exports {
  guard exports_impl.val is Some(impl_) else {
    abort("exports not registered")
  }
  impl_
}

pub fn wasmExportBlobNew(data_ptr : Int, data_len : Int) -> Int {
  let data : Array[Byte] = {
    let arr : Array[Byte] = Array::new(capacity=data_len)
    for i = 0; i < data_len; i = i + 1 {
      let elem_ptr = data_ptr + i * 1
      arr.push(@cabi.cabi_read_u8(elem_ptr))
    }
    arr
  }
  get_exports().blob_new(data).0
}

pub fn wasmExportBlobSize(handle : Int) -> Int {
  get_exports().blob_size(Blob(handle)).reinterpret_as_int()
}

pub fn wasmExportBlobRead(handle : Int, offset : Int, len : Int) -> Int {
  let result = get_exports().blob_read(Blob(handle), offset.reinterpret_as_uint(), len.reinterpret_as_uint())
  // Lower list to linear memory
  let len = result.length()
  let elem_size = 1
  let ptr = @cabi.cabi_realloc(0, 0, 1, len * elem_size)
  for i, elem in result {
    let elem_ptr = ptr + i * elem_size
    @cabi.cabi_write_u8(elem_ptr, elem)
  }
  let retptr = @cabi.cabi_realloc(0, 0, 4, 8)
  @cabi.cabi_write_i32(retptr, ptr)
  @cabi.cabi_write_i32(retptr + 4, len)
  retptr
}

pub fn wasmExportBlobWrite(handle : Int, offset : Int, data_ptr : Int, data_len : Int) -> Unit {
  let data : Array[Byte] = {
    let arr : Array[Byte] = Array::new(capacity=data_len)
    for i = 0; i < data_len; i = i + 1 {
      let elem_ptr = data_ptr + i * 1
      arr.push(@cabi.cabi_read_u8(elem_ptr))
    }
    arr
  }
  get_exports().blob_write(Blob(handle), offset.reinterpret_as_uint(), data)
}

pub fn wasmExportCreateBlob(data_ptr : Int, data_len : Int) -> Int {
  let data : Array[Byte] = {
    let arr : Array[Byte] = Array::new(capacity=data_len)
    for i = 0; i < data_len; i = i + 1 {
      let elem_ptr = data_ptr + i * 1
      arr.push(@cabi.cabi_read_u8(elem_ptr))
    }
    arr
  }
  get_exports().create_blob(data).0
}

pub fn wasmExportGetBlobSize(b : Int) -> Int {
  get_exports().get_blob_size(Blob(b)).reinterpret_as_int()
}

pub fn wasmExportConsumeBlob(b : Int) -> Int {
  let result = get_exports().consume_blob(Blob(b))
  // Lower list to linear memory
  let len = result.length()
  let elem_size = 1
  let ptr = @cabi.cabi_realloc(0, 0, 1, len * elem_size)
  for i, elem in result {
    let elem_ptr = ptr + i * elem_size
    @cabi.cabi_write_u8(elem_ptr, elem)
  }
  let retptr = @cabi.cabi_realloc(0, 0, 4, 8)
  @cabi.cabi_write_i32(retptr, ptr)
  @cabi.cabi_write_i32(retptr + 4, len)
  retptr
}

