/// Import generation for WIT interfaces

///|
fn Generator::generate_interface_import(self : Generator, id : Int) -> Unit {
  let iface = self.resolve.interfaces[id]
  let pkg = iface.pkg.map(fn(pid) { self.resolve.packages[pid] })
  let unnamed = "unnamed"
  let iface_name = iface.name.unwrap_or(unnamed)

  // Build import module name: namespace:package/interface
  let import_module = match pkg {
    Some(p) => p.name.ns + ":" + p.name.name + "/" + iface_name
    None => iface_name
  }
  let sb = StringBuilder::new()
  sb.write_string("// Generated by moon-component\n")
  sb.write_string("// Import module: ")
  sb.write_string(import_module)
  sb.write_string("\n\n")

  // Generate types first
  for _, type_id in iface.types {
    self.generate_type_def(sb, type_id)
  }

  // Collect imports for moon.pkg
  let imports : Array[(String, String, String)] = [] // (func_name, import_module, wit_func_name)
  for _, func in iface.functions {
    let func_name = to_snake_case(func.name)

    // Check if all params/result are primitive (can use direct FFI)
    let is_primitive = self.is_primitive_function(func)
    if is_primitive {
      // Direct FFI import for primitive types
      sb.write_string("///|\n")
      sb.write_string("pub fn ")
      sb.write_string(func_name)
      sb.write_string("(")
      sb.write_string(self.param_list(func.params))
      sb.write_string(") -> ")
      sb.write_string(self.result_type(func.result))
      sb.write_string(" = \"")
      sb.write_string(import_module)
      sb.write_string("\" \"")
      sb.write_string(func.name)
      sb.write_string("\"\n\n")
    } else {
      // Complex types need canonical ABI wrapper
      // Generate low-level FFI import
      let ffi_func_name = "ffi_" + func_name
      sb.write_string("///| Low-level FFI import\n")
      sb.write_string("fn ")
      sb.write_string(ffi_func_name)
      sb.write_string("(")
      sb.write_string(self.ffi_import_params(func))
      sb.write_string(") -> ")
      sb.write_string(self.ffi_import_result(func))
      sb.write_string(" = \"")
      sb.write_string(import_module)
      sb.write_string("\" \"")
      sb.write_string(func.name)
      sb.write_string("\"\n\n")

      // Generate high-level wrapper
      sb.write_string("///| High-level wrapper with canonical ABI conversion\n")
      sb.write_string("pub fn ")
      sb.write_string(func_name)
      sb.write_string("(")
      sb.write_string(self.param_list(func.params))
      sb.write_string(") -> ")
      sb.write_string(self.result_type(func.result))
      sb.write_string(" {\n")
      self.generate_import_wrapper_body(sb, func, ffi_func_name)
      sb.write_string("}\n\n")
    }
    imports.push((func_name, import_module, func.name))
  }
  let path = self.interface_path(id, "import.mbt")
  self.output.push({ path, content: sb.to_string(), is_stub: false })

  // Generate moon.pkg for import
  self.generate_import_pkg(id, imports)
}

///|
fn Generator::is_primitive_function(
  self : Generator,
  func : @resolve.Function,
) -> Bool {
  // Check all params
  for param in func.params {
    let (_, ty) = param
    if not(self.is_primitive_type(ty)) {
      return false
    }
  }
  // Check result
  match func.result {
    None => true
    Some(ty) => self.is_primitive_type(ty)
  }
}

///|
fn Generator::is_primitive_type(self : Generator, ty : @resolve.Type) -> Bool {
  match ty {
    S8 | U8 | S16 | U16 | S32 | U32 | S64 | U64 | F32 | F64 | Bool | Char =>
      true
    // With JS string builtins, string can be passed directly
    String_ => self.opts.use_js_string_builtins
    _ => false
  }
}

///|
fn Generator::ffi_import_params(
  self : Generator,
  func : @resolve.Function,
) -> String {
  let parts : Array[String] = []
  for i, param in func.params {
    let (_, ty) = param
    match ty {
      String_ =>
        if self.opts.use_js_string_builtins {
          // Direct string passing with JS string builtins
          parts.push("p" + i.to_string() + " : String")
        } else {
          // Traditional ptr+len passing
          parts.push("p" + i.to_string() + "_ptr : Int")
          parts.push("p" + i.to_string() + "_len : Int")
        }
      _ => parts.push("p" + i.to_string() + " : " + self.ffi_type(ty))
    }
  }
  // Add retptr for complex return types (string, list, etc.)
  if self.import_needs_retptr(func) {
    parts.push("retptr : Int")
  }
  parts.join(", ")
}

///|
fn Generator::import_needs_retptr(
  self : Generator,
  func : @resolve.Function,
) -> Bool {
  match func.result {
    None => false
    Some(String_) => not(self.opts.use_js_string_builtins)
    _ => false
  }
}

///|
fn Generator::ffi_import_result(
  self : Generator,
  func : @resolve.Function,
) -> String {
  match func.result {
    None => "Unit"
    Some(String_) =>
      if self.opts.use_js_string_builtins {
        "String" // Direct string return
      } else {
        // Return Int instead of Unit to work around MoonBit FFI ABI limitation
        // MoonBit generates (result i32) even for Unit returns, but Canonical ABI expects no result
        // The componentize tool will fix this by changing the import type and removing drop
        "Int"
      }
    Some(ty) => self.ffi_type(ty)
  }
}

///|
fn Generator::ffi_type(self : Generator, ty : @resolve.Type) -> String {
  match ty {
    S8 | S16 | S32 | U8 | U16 | U32 | Bool | Char => "Int"
    S64 | U64 => "Int64"
    F32 => "Float"
    F64 => "Double"
    String_ =>
      if self.opts.use_js_string_builtins {
        "String" // Direct string type
      } else {
        "Int" // ptr
      }
    _ => "Int" // fallback
  }
}

///|
fn Generator::generate_import_wrapper_body(
  self : Generator,
  sb : StringBuilder,
  func : @resolve.Function,
  ffi_func_name : String,
) -> Unit {
  sb.write_string("  // TODO: Implement canonical ABI conversion\n")
  sb.write_string("  abort(\"import wrapper not implemented\")\n")
}

///|
fn Generator::generate_import_pkg(
  self : Generator,
  id : Int,
  _imports : Array[(String, String, String)],
) -> Unit {
  let iface = self.resolve.interfaces[id]
  let sb = StringBuilder::new()
  let cabi_path = self.cabi_import_path()
  let filename = match self.opts.pkg_format {
    Json => {
      sb.write_string("{\n")
      sb.write_string("  \"import\": [\n")
      sb.write_string("    { \"path\": \"")
      sb.write_string(cabi_path)
      sb.write_string("\", \"alias\": \"cabi\" }\n")
      sb.write_string("  ]\n")
      sb.write_string("}\n")
      "moon.pkg.json"
    }
    Dsl => {
      sb.write_string("import(\n")
      sb.write_string("  \"")
      sb.write_string(cabi_path)
      sb.write_string("\" as cabi,\n")
      sb.write_string(")\n")
      "moon.pkg"
    }
  }
  let path = self.interface_path(id, filename)
  self.output.push({ path, content: sb.to_string(), is_stub: false })
}
