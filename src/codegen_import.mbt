/// Import generation for WIT interfaces

///|
fn Generator::generate_interface_import(self : Generator, id : Int) -> Unit {
  let iface = self.resolve.interfaces[id]
  let pkg = iface.pkg.map(fn(pid) { self.resolve.packages[pid] })
  let unnamed = "unnamed"
  let iface_name = iface.name.unwrap_or(unnamed)

  // Build import module name: namespace:package/interface
  let import_module = match pkg {
    Some(p) => self.interface_id(p, iface_name)
    None => iface_name
  }
  let sb = StringBuilder::new()
  sb.write_string("// Generated by moon-component\n")
  sb.write_string("// Import module: ")
  sb.write_string(import_module)
  sb.write_string("\n\n")

  // Generate types first
  for _, type_id in iface.types {
    self.generate_type_def(sb, type_id)
  }

  // Collect imports for moon.pkg
  let imports : Array[(String, String, String)] = [] // (func_name, import_module, wit_func_name)
  for _, func in iface.functions {
    let func_name = to_snake_case(func.name)

    // Check if all params/result are primitive (can use direct FFI)
    let is_primitive = self.is_primitive_function(func)
    if is_primitive {
      // Direct FFI import for primitive types
      sb.write_string("///|\n")
      sb.write_string("pub fn ")
      sb.write_string(func_name)
      sb.write_string("(")
      sb.write_string(self.param_list(func.params))
      sb.write_string(") -> ")
      sb.write_string(self.result_type(func.result))
      sb.write_string(" = \"")
      sb.write_string(import_module)
      sb.write_string("\" \"")
      sb.write_string(func.name)
      sb.write_string("\"\n\n")
    } else {
      // Complex types need canonical ABI wrapper
      // Generate low-level FFI import
      let ffi_func_name = "ffi_" + func_name
      sb.write_string("///| Low-level FFI import\n")
      sb.write_string("fn ")
      sb.write_string(ffi_func_name)
      sb.write_string("(")
      sb.write_string(self.ffi_import_params(func))
      sb.write_string(") -> ")
      sb.write_string(self.ffi_import_result(func))
      sb.write_string(" = \"")
      sb.write_string(import_module)
      sb.write_string("\" \"")
      sb.write_string(func.name)
      sb.write_string("\"\n\n")

      // Generate high-level wrapper
      sb.write_string("///| High-level wrapper with canonical ABI conversion\n")
      sb.write_string("pub fn ")
      sb.write_string(func_name)
      sb.write_string("(")
      sb.write_string(self.param_list(func.params))
      sb.write_string(") -> ")
      sb.write_string(self.result_type(func.result))
      sb.write_string(" {\n")
      self.generate_import_wrapper_body(sb, func, ffi_func_name)
      sb.write_string("}\n\n")
    }
    imports.push((func_name, import_module, func.name))
  }
  let path = self.interface_path(id, "import.mbt")
  self.output.push({ path, content: sb.to_string(), is_stub: false })

  // Generate moon.pkg for import
  self.generate_import_pkg(id, imports)
}

///|
fn Generator::generate_world_function_imports(
  self : Generator,
  world : @resolve.World,
) -> Unit {
  let funcs : Array[@resolve.Function] = []
  for _, item in world.imports {
    match item {
      Function(func) => funcs.push(func)
      _ => ()
    }
  }
  if funcs.length() == 0 {
    return
  }

  // Build import module name: namespace:package/world
  let import_module = match world.pkg {
    Some(pkg_id) => {
      let pkg = self.resolve.packages[pkg_id]
      self.interface_id(pkg, world.name)
    }
    None => world.name
  }
  let sb = StringBuilder::new()
  sb.write_string("// Generated by moon-component\n")
  sb.write_string("// Import module: ")
  sb.write_string(import_module)
  sb.write_string("\n\n")

  // Generate types for world-owned definitions
  for type_id, typedef in self.resolve.types {
    match typedef.owner {
      World(world_id) =>
        if world_id == self.world_id {
          self.generate_type_def(sb, type_id)
        }
      _ => ()
    }
  }

  // Collect imports for moon.pkg
  let imports : Array[(String, String, String)] = []
  for _, func in funcs {
    let func_name = to_snake_case(func.name)
    let is_primitive = self.is_primitive_function(func)
    if is_primitive {
      sb.write_string("///|\n")
      sb.write_string("pub fn ")
      sb.write_string(func_name)
      sb.write_string("(")
      sb.write_string(self.param_list(func.params))
      sb.write_string(") -> ")
      sb.write_string(self.result_type(func.result))
      sb.write_string(" = \"")
      sb.write_string(import_module)
      sb.write_string("\" \"")
      sb.write_string(func.name)
      sb.write_string("\"\n\n")
    } else {
      let ffi_func_name = "ffi_" + func_name
      sb.write_string("///| Low-level FFI import\n")
      sb.write_string("fn ")
      sb.write_string(ffi_func_name)
      sb.write_string("(")
      sb.write_string(self.ffi_import_params(func))
      sb.write_string(") -> ")
      sb.write_string(self.ffi_import_result(func))
      sb.write_string(" = \"")
      sb.write_string(import_module)
      sb.write_string("\" \"")
      sb.write_string(func.name)
      sb.write_string("\"\n\n")
      sb.write_string("///| High-level wrapper with canonical ABI conversion\n")
      sb.write_string("pub fn ")
      sb.write_string(func_name)
      sb.write_string("(")
      sb.write_string(self.param_list(func.params))
      sb.write_string(") -> ")
      sb.write_string(self.result_type(func.result))
      sb.write_string(" {\n")
      self.generate_import_wrapper_body(sb, func, ffi_func_name)
      sb.write_string("}\n\n")
    }
    imports.push((func_name, import_module, func.name))
  }
  let path = self.world_path(world, "import.mbt")
  self.output.push({ path, content: sb.to_string(), is_stub: false })
  self.generate_world_import_pkg(world, imports)
}

///|
fn Generator::is_primitive_function(
  self : Generator,
  func : @resolve.Function,
) -> Bool {
  // Check all params
  for param in func.params {
    let (_, ty) = param
    if not(self.is_primitive_type(ty)) {
      return false
    }
  }
  // Check result
  match func.result {
    None => true
    Some(ty) => self.is_primitive_type(ty)
  }
}

///|
fn Generator::is_primitive_type(self : Generator, ty : @resolve.Type) -> Bool {
  match ty {
    S8 | U8 | S16 | U16 | S32 | U32 | S64 | U64 | F32 | F64 | Bool | Char =>
      true
    // With JS string builtins, string can be passed directly
    String_ => self.opts.use_js_string_builtins
    _ => false
  }
}

///|
fn Generator::ffi_import_params(
  self : Generator,
  func : @resolve.Function,
) -> String {
  let parts : Array[String] = []
  for i, param in func.params {
    let (_, ty) = param
    match ty {
      String_ =>
        if self.opts.use_js_string_builtins {
          // Direct string passing with JS string builtins
          parts.push("p" + i.to_string() + " : String")
        } else {
          // Traditional ptr+len passing
          parts.push("p" + i.to_string() + "_ptr : Int")
          parts.push("p" + i.to_string() + "_len : Int")
        }
      Id(id) => {
        let typedef = self.resolve.types[id]
        match typedef.kind {
          List(_) => {
            parts.push("p" + i.to_string() + "_ptr : Int")
            parts.push("p" + i.to_string() + "_len : Int")
          }
          _ => parts.push("p" + i.to_string() + " : " + self.ffi_type(ty))
        }
      }
      _ => parts.push("p" + i.to_string() + " : " + self.ffi_type(ty))
    }
  }
  // Add retptr for complex return types (string, list, etc.)
  if self.import_needs_retptr(func) {
    parts.push("retptr : Int")
  }
  parts.join(", ")
}

///|
fn Generator::import_needs_retptr(
  self : Generator,
  func : @resolve.Function,
) -> Bool {
  match func.result {
    None => false
    Some(ty) => self.import_needs_retptr_type(ty)
  }
}

///|
fn Generator::import_needs_retptr_type(
  self : Generator,
  ty : @resolve.Type,
) -> Bool {
  match ty {
    String_ => not(self.opts.use_js_string_builtins)
    Id(id) => {
      let typedef = self.resolve.types[id]
      match typedef.kind {
        List(_)
        | Record(_)
        | Variant(_)
        | Option(_)
        | Result(ok=_, err=_)
        | Tuple(_) => true
        Alias(inner) => self.import_needs_retptr_type(inner)
        _ => false
      }
    }
    _ => false
  }
}

///|
fn Generator::ffi_import_result(
  self : Generator,
  func : @resolve.Function,
) -> String {
  match func.result {
    None => "Unit"
    Some(ty) =>
      if self.import_needs_retptr(func) {
        // Return Int instead of Unit to work around MoonBit FFI ABI limitation
        // MoonBit generates (result i32) even for Unit returns, but Canonical ABI expects no result
        // The componentize tool will fix this by changing the import type and removing drop
        "Int"
      } else {
        self.ffi_type(ty)
      }
  }
}

///|
fn Generator::ffi_type(self : Generator, ty : @resolve.Type) -> String {
  match ty {
    S8 | S16 | S32 | U8 | U16 | U32 | Bool | Char => "Int"
    S64 | U64 => "Int64"
    F32 => "Float"
    F64 => "Double"
    String_ =>
      if self.opts.use_js_string_builtins {
        "String" // Direct string type
      } else {
        "Int" // ptr
      }
    _ => "Int" // fallback
  }
}

///|
fn Generator::generate_import_wrapper_body(
  self : Generator,
  sb : StringBuilder,
  func : @resolve.Function,
  ffi_func_name : String,
) -> Unit {
  let ffi_args : Array[String] = []
  for i, param in func.params {
    let (name, ty) = param
    let snake_name = to_snake_case(name)
    let safe_name = if snake_name == "self" { "handle" } else { snake_name }
    match ty {
      String_ =>
        if self.opts.use_js_string_builtins {
          ffi_args.push(safe_name)
        } else {
          sb.write_string("  let (p")
          sb.write_string(i.to_string())
          sb.write_string("_ptr, p")
          sb.write_string(i.to_string())
          sb.write_string("_len) = @cabi.cabi_lower_string(")
          sb.write_string(safe_name)
          sb.write_string(")\n")
          ffi_args.push("p" + i.to_string() + "_ptr")
          ffi_args.push("p" + i.to_string() + "_len")
        }
      Bool => ffi_args.push("if " + safe_name + " { 1 } else { 0 }")
      U8 => ffi_args.push(safe_name + ".to_int()")
      U16 | U32 => ffi_args.push(safe_name + ".reinterpret_as_int()")
      U64 => ffi_args.push(safe_name + ".reinterpret_as_int64()")
      Char => ffi_args.push(safe_name + ".to_int()")
      Id(id) => {
        let typedef = self.resolve.types[id]
        match typedef.kind {
          List(inner) => {
            let elem_size = self.type_size(inner)
            let elem_align = self.type_align(inner)
            sb.write_string("  let p")
            sb.write_string(i.to_string())
            sb.write_string("_len = ")
            sb.write_string(safe_name)
            sb.write_string(".length()\n")
            sb.write_string("  let p")
            sb.write_string(i.to_string())
            sb.write_string("_ptr = @cabi.cabi_realloc(0, 0, ")
            sb.write_string(elem_align.to_string())
            sb.write_string(", p")
            sb.write_string(i.to_string())
            sb.write_string("_len * ")
            sb.write_string(elem_size.to_string())
            sb.write_string(")\n")
            sb.write_string("  for i, elem in ")
            sb.write_string(safe_name)
            sb.write_string(" {\n")
            sb.write_string("    let elem_ptr = p")
            sb.write_string(i.to_string())
            sb.write_string("_ptr + i * ")
            sb.write_string(elem_size.to_string())
            sb.write_string("\n")
            self.generate_list_elem_lower(sb, inner, "elem_ptr", "elem")
            sb.write_string("  }\n")
            ffi_args.push("p" + i.to_string() + "_ptr")
            ffi_args.push("p" + i.to_string() + "_len")
          }
          Record(_) => {
            let size = self.type_size(ty)
            let align = self.type_align(ty)
            sb.write_string("  let p")
            sb.write_string(i.to_string())
            sb.write_string("_ptr = @cabi.cabi_realloc(0, 0, ")
            sb.write_string(align.to_string())
            sb.write_string(", ")
            sb.write_string(size.to_string())
            sb.write_string(")\n")
            self.generate_value_lower(
              sb,
              "p" + i.to_string() + "_ptr",
              ty,
              safe_name,
              "  ",
            )
            ffi_args.push("p" + i.to_string() + "_ptr")
          }
          Option(inner) => {
            // Option = 2-case variant: disc_size=1
            let payload_align = self.type_align(inner)
            let payload_offset = align_to(
              1,
              if payload_align > 1 { payload_align } else { 1 },
            )
            let total_size = payload_offset + self.type_size(inner)
            let alloc_align = self.type_align(Id(id))
            sb.write_string("  let p")
            sb.write_string(i.to_string())
            sb.write_string("_ptr = @cabi.cabi_realloc(0, 0, ")
            sb.write_string(alloc_align.to_string())
            sb.write_string(", ")
            sb.write_string(total_size.to_string())
            sb.write_string(")\n")
            sb.write_string("  match ")
            sb.write_string(safe_name)
            sb.write_string(" {\n")
            sb.write_string("    Some(val) => {\n")
            sb.write_string("      ")
            sb.write_string(
              disc_write_code("p" + i.to_string() + "_ptr", "1", 2),
            )
            sb.write_string("\n")
            self.generate_value_lower(
              sb,
              "p" + i.to_string() + "_ptr + " + payload_offset.to_string(),
              inner,
              "val",
              "      ",
            )
            sb.write_string("    }\n")
            sb.write_string("    None => ")
            sb.write_string(
              disc_write_code("p" + i.to_string() + "_ptr", "0", 2),
            )
            sb.write_string("\n")
            sb.write_string("  }\n")
            ffi_args.push("p" + i.to_string() + "_ptr")
          }
          Result(ok=ok_ty, err=err_ty) => {
            let ok_size = match ok_ty {
              Some(t) => self.type_size(t)
              None => 0
            }
            let err_size = match err_ty {
              Some(t) => self.type_size(t)
              None => 0
            }
            let ok_align = match ok_ty {
              Some(t) => self.type_align(t)
              None => 1
            }
            let err_align = match err_ty {
              Some(t) => self.type_align(t)
              None => 1
            }
            let max_payload_align = if ok_align > err_align {
              ok_align
            } else {
              err_align
            }
            let payload_size = if ok_size > err_size { ok_size } else { err_size }
            // Result = 2-case variant: disc_size=1
            let payload_offset = align_to(
              1,
              if max_payload_align > 1 { max_payload_align } else { 1 },
            )
            let total_size = payload_offset + payload_size
            let alloc_align = self.type_align(Id(id))
            let ptr_name = "p" + i.to_string() + "_ptr"
            let po_str = ptr_name + " + " + payload_offset.to_string()
            sb.write_string("  let ")
            sb.write_string(ptr_name)
            sb.write_string(" = @cabi.cabi_realloc(0, 0, ")
            sb.write_string(alloc_align.to_string())
            sb.write_string(", ")
            sb.write_string(total_size.to_string())
            sb.write_string(")\n")
            sb.write_string("  match ")
            sb.write_string(safe_name)
            sb.write_string(" {\n")
            sb.write_string("    Ok(val) => {\n")
            sb.write_string("      ")
            sb.write_string(disc_write_code(ptr_name, "0", 2))
            sb.write_string("\n")
            match ok_ty {
              Some(t) =>
                self.generate_value_lower(sb, po_str, t, "val", "      ")
              None => ()
            }
            sb.write_string("    }\n")
            sb.write_string("    Err(e) => {\n")
            sb.write_string("      ")
            sb.write_string(disc_write_code(ptr_name, "1", 2))
            sb.write_string("\n")
            match err_ty {
              Some(t) =>
                self.generate_value_lower(sb, po_str, t, "e", "      ")
              None => ()
            }
            sb.write_string("    }\n")
            sb.write_string("  }\n")
            ffi_args.push(ptr_name)
          }
          Variant(cases) => {
            let payload_offset = self.variant_payload_offset(cases)
            let mut max_payload = 0
            for case in cases {
              match case.case_type {
                Some(t) => {
                  let size = self.type_size(t)
                  if size > max_payload {
                    max_payload = size
                  }
                }
                None => ()
              }
            }
            let total_size = payload_offset + max_payload
            let alloc_align = self.type_align(Id(id))
            let ptr_name = "p" + i.to_string() + "_ptr"
            let po_str = ptr_name + " + " + payload_offset.to_string()
            sb.write_string("  let ")
            sb.write_string(ptr_name)
            sb.write_string(" = @cabi.cabi_realloc(0, 0, ")
            sb.write_string(alloc_align.to_string())
            sb.write_string(", ")
            sb.write_string(total_size.to_string())
            sb.write_string(")\n")
            sb.write_string("  match ")
            sb.write_string(safe_name)
            sb.write_string(" {\n")
            for case_i, case in cases {
              sb.write_string("    ")
              sb.write_string(to_pascal_case(case.name))
              match case.case_type {
                Some(_) => sb.write_string("(val)")
                None => ()
              }
              sb.write_string(" => {\n")
              sb.write_string("      ")
              sb.write_string(
                disc_write_code(
                  ptr_name,
                  case_i.to_string(),
                  cases.length(),
                ),
              )
              sb.write_string("\n")
              match case.case_type {
                Some(t) =>
                  self.generate_value_lower(sb, po_str, t, "val", "      ")
                None => ()
              }
              sb.write_string("    }\n")
            }
            sb.write_string("  }\n")
            ffi_args.push(ptr_name)
          }
          Flags(_) => ffi_args.push(safe_name + ".to_bits()")
          Enum(_) => ffi_args.push(safe_name + ".ordinal()")
          Resource | Handle(_) => ffi_args.push(safe_name + ".0")
          Alias(inner) =>
            match inner {
              String_ =>
                if self.opts.use_js_string_builtins {
                  ffi_args.push(safe_name)
                } else {
                  sb.write_string("  let (p")
                  sb.write_string(i.to_string())
                  sb.write_string("_ptr, p")
                  sb.write_string(i.to_string())
                  sb.write_string("_len) = @cabi.cabi_lower_string(")
                  sb.write_string(safe_name)
                  sb.write_string(")\n")
                  ffi_args.push("p" + i.to_string() + "_ptr")
                  ffi_args.push("p" + i.to_string() + "_len")
                }
              _ => ffi_args.push(safe_name)
            }
          _ => ffi_args.push(safe_name)
        }
      }
      _ => ffi_args.push(safe_name)
    }
  }
  if self.import_needs_retptr(func) {
    let retptr_size = match func.result {
      Some(ty) => self.import_retptr_size(ty)
      None => 0
    }
    sb.write_string("  let retptr = @cabi.cabi_realloc(0, 0, 4, ")
    sb.write_string(retptr_size.to_string())
    sb.write_string(")\n")
    ffi_args.push("retptr")
    sb.write_string("  let _ = ")
    sb.write_string(ffi_func_name)
    sb.write_string("(")
    sb.write_string(ffi_args.join(", "))
    sb.write_string(")\n")
    match func.result {
      Some(ty) => self.generate_import_retptr_result(sb, ty)
      None => sb.write_string("  ()\n")
    }
  } else {
    match func.result {
      None => {
        sb.write_string("  ")
        sb.write_string(ffi_func_name)
        sb.write_string("(")
        sb.write_string(ffi_args.join(", "))
        sb.write_string(")\n")
      }
      Some(ty) => {
        sb.write_string("  let result = ")
        sb.write_string(ffi_func_name)
        sb.write_string("(")
        sb.write_string(ffi_args.join(", "))
        sb.write_string(")\n")
        sb.write_string("  ")
        sb.write_string(self.import_direct_result_expr("result", ty))
        sb.write_string("\n")
      }
    }
  }
}

///|
fn Generator::import_retptr_size(self : Generator, ty : @resolve.Type) -> Int {
  match ty {
    String_ => 8
    Id(id) => {
      let typedef = self.resolve.types[id]
      match typedef.kind {
        List(_) => 8
        Record(fields) => self.compute_record_size(fields)
        Option(inner) => {
          // Option is variant with 2 cases: disc_size=1
          let payload_align = self.type_align(inner)
          let payload_offset = align_to(1, if payload_align > 1 { payload_align } else { 1 })
          payload_offset + self.type_size(inner)
        }
        Result(ok=ok_ty, err=err_ty) => {
          let ok_size = match ok_ty {
            Some(t) => self.type_size(t)
            None => 0
          }
          let err_size = match err_ty {
            Some(t) => self.type_size(t)
            None => 0
          }
          let ok_align = match ok_ty {
            Some(t) => self.type_align(t)
            None => 1
          }
          let err_align = match err_ty {
            Some(t) => self.type_align(t)
            None => 1
          }
          let max_payload_align = if ok_align > err_align {
            ok_align
          } else {
            err_align
          }
          let payload_size = if ok_size > err_size { ok_size } else { err_size }
          // Result is variant with 2 cases: disc_size=1
          let payload_offset = align_to(
            1,
            if max_payload_align > 1 { max_payload_align } else { 1 },
          )
          payload_offset + payload_size
        }
        Variant(cases) => {
          let mut max_payload = 0
          let mut max_payload_align = 1
          for case in cases {
            match case.case_type {
              Some(t) => {
                let size = self.type_size(t)
                if size > max_payload {
                  max_payload = size
                }
                let a = self.type_align(t)
                if a > max_payload_align {
                  max_payload_align = a
                }
              }
              None => ()
            }
          }
          let ds = disc_size(cases.length())
          let payload_offset = align_to(
            ds,
            if max_payload_align > 1 { max_payload_align } else { 1 },
          )
          payload_offset + max_payload
        }
        Tuple(types) => {
          let mut size = 0
          for t in types {
            let align = self.type_align(t)
            size = (size + align - 1) & -align
            size = size + self.type_size(t)
          }
          size
        }
        Alias(inner) => self.import_retptr_size(inner)
        _ => 8
      }
    }
    _ => 8
  }
}

///|
fn Generator::import_direct_result_expr(
  self : Generator,
  result_var : String,
  ty : @resolve.Type,
) -> String {
  match ty {
    Bool => result_var + " != 0"
    U8 => result_var + ".to_byte()"
    U16 | U32 => result_var + ".reinterpret_as_uint()"
    U64 => result_var + ".reinterpret_as_uint64()"
    Char => result_var + ".unsafe_to_char()"
    Id(id) => {
      let typedef = self.resolve.types[id]
      match typedef.kind {
        Flags(_) =>
          self.resolve_type_name(id) + "::from_bits(" + result_var + ")"
        Enum(_) =>
          self.resolve_type_name(id) + "::from_ordinal(" + result_var + ")"
        Resource => self.resolve_type_name(id) + "(" + result_var + ")"
        Handle(handle) => {
          let res_id = match handle {
            Own(rid) => rid
            Borrow(rid) => rid
          }
          self.resolve_type_name(res_id) + "(" + result_var + ")"
        }
        Alias(inner) => self.import_direct_result_expr(result_var, inner)
        _ => result_var
      }
    }
    _ => result_var
  }
}

///|
fn Generator::generate_import_retptr_result(
  self : Generator,
  sb : StringBuilder,
  ty : @resolve.Type,
) -> Unit {
  match ty {
    String_ => {
      sb.write_string("  let result_ptr = @cabi.cabi_read_i32(retptr)\n")
      sb.write_string("  let result_len = @cabi.cabi_read_i32(retptr + 4)\n")
      sb.write_string("  @cabi.cabi_lift_string(result_ptr, result_len)\n")
    }
    Id(id) => {
      let typedef = self.resolve.types[id]
      match typedef.kind {
        List(inner) => {
          let elem_size = self.type_size(inner)
          sb.write_string("  let result_ptr = @cabi.cabi_read_i32(retptr)\n")
          sb.write_string(
            "  let result_len = @cabi.cabi_read_i32(retptr + 4)\n",
          )
          sb.write_string("  let result : Array[")
          sb.write_string(self.type_name(inner))
          sb.write_string("] = {\n")
          sb.write_string("    let arr : Array[")
          sb.write_string(self.type_name(inner))
          sb.write_string("] = Array::new(capacity=result_len)\n")
          sb.write_string("    for i = 0; i < result_len; i = i + 1 {\n")
          sb.write_string("      let elem_ptr = result_ptr + i * ")
          sb.write_string(elem_size.to_string())
          sb.write_string("\n")
          sb.write_string("      arr.push(")
          sb.write_string(self.generate_list_elem_lift(inner, "elem_ptr"))
          sb.write_string(")\n")
          sb.write_string("    }\n")
          sb.write_string("    arr\n")
          sb.write_string("  }\n")
          sb.write_string("  result\n")
        }
        Record(_) => {
          sb.write_string("  ")
          sb.write_string(self.generate_field_lift("retptr", 0, ty))
          sb.write_string("\n")
        }
        Option(inner) => {
          // Option = 2-case variant: disc_size=1
          let payload_align = self.type_align(inner)
          let payload_offset = align_to(
            1,
            if payload_align > 1 { payload_align } else { 1 },
          )
          sb.write_string("  match ")
          sb.write_string(disc_read_code("retptr", 2))
          sb.write_string(" {\n")
          sb.write_string("    0 => None\n")
          sb.write_string("    _ => Some(")
          sb.write_string(
            self.generate_field_lift(
              "retptr + " + payload_offset.to_string(),
              0,
              inner,
            ),
          )
          sb.write_string(")\n")
          sb.write_string("  }\n")
        }
        Result(ok=ok_ty, err=err_ty) => {
          // Result = 2-case variant: disc_size=1
          let ok_align = match ok_ty {
            Some(t) => self.type_align(t)
            None => 1
          }
          let err_align = match err_ty {
            Some(t) => self.type_align(t)
            None => 1
          }
          let max_payload_align = if ok_align > err_align {
            ok_align
          } else {
            err_align
          }
          let payload_offset = align_to(
            1,
            if max_payload_align > 1 { max_payload_align } else { 1 },
          )
          let po_str = "retptr + " + payload_offset.to_string()
          sb.write_string("  match ")
          sb.write_string(disc_read_code("retptr", 2))
          sb.write_string(" {\n")
          sb.write_string("    0 => ")
          match ok_ty {
            Some(t) => {
              sb.write_string("Ok(")
              sb.write_string(self.generate_field_lift(po_str, 0, t))
              sb.write_string(")\n")
            }
            None => sb.write_string("Ok(())\n")
          }
          sb.write_string("    _ => ")
          match err_ty {
            Some(t) => {
              sb.write_string("Err(")
              sb.write_string(self.generate_field_lift(po_str, 0, t))
              sb.write_string(")\n")
            }
            None => sb.write_string("Err(())\n")
          }
          sb.write_string("  }\n")
        }
        Variant(cases) => {
          let payload_offset = self.variant_payload_offset(cases)
          let po_str = "retptr + " + payload_offset.to_string()
          sb.write_string("  match ")
          sb.write_string(disc_read_code("retptr", cases.length()))
          sb.write_string(" {\n")
          for case_i, case in cases {
            sb.write_string("    ")
            sb.write_string(case_i.to_string())
            sb.write_string(" => ")
            sb.write_string(to_pascal_case(case.name))
            match case.case_type {
              Some(t) => {
                sb.write_string("(")
                sb.write_string(self.generate_field_lift(po_str, 0, t))
                sb.write_string(")\n")
              }
              None => sb.write_string("\n")
            }
          }
          sb.write_string("    _ => abort(\"invalid variant discriminant\")\n")
          sb.write_string("  }\n")
        }
        Alias(inner) => self.generate_import_retptr_result(sb, inner)
        _ => sb.write_string("  @cabi.cabi_read_i32(retptr)\n")
      }
    }
    _ => sb.write_string("  @cabi.cabi_read_i32(retptr)\n")
  }
}

///|
fn Generator::generate_import_pkg(
  self : Generator,
  id : Int,
  _imports : Array[(String, String, String)],
) -> Unit {
  let sb = StringBuilder::new()
  let cabi_path = self.cabi_import_path()
  let filename = match self.opts.pkg_format {
    Json => {
      sb.write_string("{\n")
      sb.write_string("  \"import\": [\n")
      sb.write_string("    { \"path\": \"")
      sb.write_string(cabi_path)
      sb.write_string("\", \"alias\": \"cabi\" }\n")
      sb.write_string("  ]\n")
      sb.write_string("}\n")
      "moon.pkg.json"
    }
    Dsl => {
      sb.write_string("import(\n")
      sb.write_string("  \"")
      sb.write_string(cabi_path)
      sb.write_string("\" as cabi,\n")
      sb.write_string(")\n")
      "moon.pkg"
    }
  }
  let path = self.interface_path(id, filename)
  self.output.push({ path, content: sb.to_string(), is_stub: false })
}

///|
fn Generator::generate_world_import_pkg(
  self : Generator,
  world : @resolve.World,
  _imports : Array[(String, String, String)],
) -> Unit {
  let sb = StringBuilder::new()
  let cabi_path = self.cabi_import_path()
  let filename = match self.opts.pkg_format {
    Json => {
      sb.write_string("{\n")
      sb.write_string("  \"import\": [\n")
      sb.write_string("    { \"path\": \"")
      sb.write_string(cabi_path)
      sb.write_string("\", \"alias\": \"cabi\" }\n")
      sb.write_string("  ]\n")
      sb.write_string("}\n")
      "moon.pkg.json"
    }
    Dsl => {
      sb.write_string("import(\n")
      sb.write_string("  \"")
      sb.write_string(cabi_path)
      sb.write_string("\" as cabi,\n")
      sb.write_string(")\n")
      "moon.pkg"
    }
  }
  let path = self.world_path(world, filename)
  self.output.push({ path, content: sb.to_string(), is_stub: false })
}
