/// Export generation for WIT interfaces

///|
fn Generator::generate_interface_export(self : Generator, id : Int) -> Unit {
  let iface = self.resolve.interfaces[id]
  let unnamed = "unnamed"
  let iface_name = iface.name.unwrap_or(unnamed)
  let pkg = iface.pkg.map(fn(pid) { self.resolve.packages[pid] })
  let sb = StringBuilder::new()

  // Header
  sb.write_string("// Generated by moon-component\n")
  sb.write_string("// DO NOT EDIT - this file is regenerated\n\n")

  // Generate type definitions for this interface
  for _, type_id in iface.types {
    self.generate_type_def(sb, type_id)
  }

  // cabi_realloc re-export
  sb.write_string("///| Re-export cabi_realloc for wasm linking\n")
  sb.write_string("pub fn cabi_realloc(\n")
  sb.write_string("  old_ptr : Int,\n")
  sb.write_string("  old_size : Int,\n")
  sb.write_string("  align : Int,\n")
  sb.write_string("  new_size : Int,\n")
  sb.write_string(") -> Int {\n")
  sb.write_string("  @cabi.cabi_realloc(old_ptr, old_size, align, new_size)\n")
  sb.write_string("}\n\n")

  // FFI export wrappers
  let exports : Array[(String, String, Array[String], String, Bool)] = []
  for _, func in iface.functions {
    let export_info = self.generate_ffi_export(sb, func, iface_name, pkg)
    exports.push(export_info)
  }

  // Main function (required for is-main package)
  sb.write_string("///|\nfn main {\n  ()\n}\n")

  // Output to impl/bindings.mbt
  let path = self.impl_path("bindings.mbt")
  self.output.push({ path, content: sb.to_string(), is_stub: false })

  // Collect export info for moon.pkg.json generation
  for exp in exports {
    let (func_name, wit_name, ffi_params, ffi_return_type, returns_indirect) = exp
    self.exports_info.push({
      func_name,
      wit_name,
      ffi_params,
      ffi_return_type,
      returns_indirect,
    })
  }

  // Generate impl/impl.mbt (user implementation)
  if self.opts.generate_impl {
    self.generate_impl(iface_name, iface)
  }
}

///|
fn Generator::generate_world_function_exports(
  self : Generator,
  world : @resolve.World,
) -> Unit {
  let funcs : Array[@resolve.Function] = []
  for _, item in world.exports {
    match item {
      Function(func) => funcs.push(func)
      _ => ()
    }
  }
  if funcs.length() == 0 {
    return
  }
  let sb = StringBuilder::new()
  sb.write_string("// Generated by moon-component\n")
  sb.write_string("// DO NOT EDIT - this file is regenerated\n\n")

  // Generate type definitions for world-owned types
  for type_id, typedef in self.resolve.types {
    match typedef.owner {
      World(world_id) =>
        if world_id == self.world_id {
          self.generate_type_def(sb, type_id)
        }
      _ => ()
    }
  }

  // cabi_realloc re-export
  sb.write_string("///| Re-export cabi_realloc for wasm linking\n")
  sb.write_string("pub fn cabi_realloc(\n")
  sb.write_string("  old_ptr : Int,\n")
  sb.write_string("  old_size : Int,\n")
  sb.write_string("  align : Int,\n")
  sb.write_string("  new_size : Int,\n")
  sb.write_string(") -> Int {\n")
  sb.write_string("  @cabi.cabi_realloc(old_ptr, old_size, align, new_size)\n")
  sb.write_string("}\n\n")

  // FFI export wrappers
  let exports : Array[(String, String, Array[String], String, Bool)] = []
  let pkg = world.pkg.map(fn(pid) { self.resolve.packages[pid] })
  for func in funcs {
    let export_info = self.generate_ffi_export(sb, func, world.name, pkg)
    exports.push(export_info)
  }

  // Main function (required for is-main package)
  sb.write_string("///|\nfn main {\n  ()\n}\n")

  // Output to impl/bindings.mbt
  let path = self.impl_path("bindings.mbt")
  self.output.push({ path, content: sb.to_string(), is_stub: false })

  // Collect export info for moon.pkg.json generation
  for exp in exports {
    let (func_name, wit_name, ffi_params, ffi_return_type, returns_indirect) = exp
    self.exports_info.push({
      func_name,
      wit_name,
      ffi_params,
      ffi_return_type,
      returns_indirect,
    })
  }

  // Generate impl/impl.mbt (user implementation)
  if self.opts.generate_impl {
    self.generate_world_impl(world.name, funcs)
  }
}

///|
fn Generator::generate_ffi_export(
  self : Generator,
  sb : StringBuilder,
  func : @resolve.Function,
  iface_name : String,
  pkg : @resolve.Package?,
) -> (String, String, Array[String], String, Bool) {
  let normalized_name = normalize_func_name(func.name, func.kind)
  let export_name = to_camel_case(normalized_name)
  let func_name = "wasmExport" + export_name
  // Build WIT export name for moon.pkg.json
  let wit_export_name = match pkg {
    Some(p) => self.interface_id(p, iface_name) + "#" + func.name
    None => iface_name + "#" + func.name
  }
  sb.write_string("pub fn ")
  sb.write_string(func_name)
  sb.write_string("(")

  // Parameters - String becomes (ptr, len)
  // Rename 'self' to 'handle' to avoid being interpreted as a method
  let ffi_params : Array[String] = []
  for param in func.params {
    let (pname, ptype) = param
    let snake_name = to_snake_case(pname)
    let safe_name = if snake_name == "self" { "handle" } else { snake_name }
    let ffi_param = self.type_to_ffi_params(safe_name, ptype)
    for p in ffi_param {
      ffi_params.push(p)
    }
  }
  sb.write_string(ffi_params.join(", "))

  // Return type - complex types return pointer to (ptr, len) structure
  let returns_indirect = self.type_returns_multivalue(func.result)
  let ffi_return_type = if returns_indirect {
    "Int" // Pointer to result structure in linear memory
  } else {
    self.result_to_ffi(func.result)
  }
  sb.write_string(") -> ")
  sb.write_string(ffi_return_type)
  sb.write_string(" {\n")

  // Lift parameters
  for param in func.params {
    let (pname, ptype) = param
    let snake_name = to_snake_case(pname)
    let safe_name = if snake_name == "self" { "handle" } else { snake_name }
    let lift = self.generate_param_lift(safe_name, ptype)
    if lift.length() > 0 {
      sb.write_string("  ")
      sb.write_string(lift)
      sb.write_string("\n")
    }
  }

  // Call user implementation
  let call_args : Array[String] = []
  for param in func.params {
    let (pname, ptype) = param
    let snake_name = to_snake_case(pname)
    let safe_name = if snake_name == "self" { "handle" } else { snake_name }
    call_args.push(self.lifted_param_name(safe_name, ptype))
  }
  // Special-case result<unit, unit> to return discriminant directly
  let unit_result = match func.result {
    Some(ty) => self.is_unit_result(ty)
    None => false
  }
  if returns_indirect {
    // Complex return: allocate result structure and return pointer
    sb.write_string("  let result = ")
    sb.write_string(normalized_name)
    sb.write_string("(")
    sb.write_string(call_args.join(", "))
    sb.write_string(")\n")
    self.generate_result_lower_indirect(sb, func.result)
  } else if unit_result {
    // result<unit, unit> -> return discriminant directly
    sb.write_string("  let result = ")
    sb.write_string(normalized_name)
    sb.write_string("(")
    sb.write_string(call_args.join(", "))
    sb.write_string(")\n")
    sb.write_string("  match result {\n")
    sb.write_string("    Ok(_) => 0\n")
    sb.write_string("    Err(_) => 1\n")
    sb.write_string("  }\n")
  } else {
    // Simple return
    let result_conv = self.ffi_to_type_conv(func.result)
    sb.write_string("  ")
    if result_conv.0.length() > 0 {
      sb.write_string(result_conv.0)
    }
    sb.write_string(normalized_name)
    sb.write_string("(")
    sb.write_string(call_args.join(", "))
    sb.write_string(")")
    sb.write_string(result_conv.1)
    sb.write_string("\n")
  }
  sb.write_string("}\n\n")
  (func_name, wit_export_name, ffi_params, ffi_return_type, returns_indirect)
}

///|
/// Check if return type needs multi-value return (via retptr)

///|
/// Generate FFI parameter list (String becomes ptr + len)
fn Generator::type_to_ffi_params(
  self : Generator,
  name : String,
  ty : @resolve.Type,
) -> Array[String] {
  match ty {
    String_ =>
      if self.opts.use_js_string_builtins {
        [name + " : String"]
      } else {
        [name + "_ptr : Int", name + "_len : Int"]
      }
    Id(id) => {
      let typedef = self.resolve.types[id]
      match typedef.kind {
        List(_) => [name + "_ptr : Int", name + "_len : Int"]
        Record(_) | Variant(_) => [name + "_ptr : Int"]
        Flags(_) => [name + " : Int"] // bitmask
        _ => [name + " : " + self.type_to_ffi(ty)]
      }
    }
    _ => [name + " : " + self.type_to_ffi(ty)]
  }
}

///|
/// Check if return type needs multi-value return (via retptr)
fn Generator::is_unit_result(self : Generator, ty : @resolve.Type) -> Bool {
  match ty {
    Id(id) => {
      let typedef = self.resolve.types[id]
      match typedef.kind {
        Result(ok~, err~) =>
          match (ok, err) {
            (None, None) => true
            _ => false
          }
        _ => false
      }
    }
    _ => false
  }
}

///|
/// Check if return type needs multi-value return (via retptr)
fn Generator::type_returns_multivalue(
  self : Generator,
  result : @resolve.Type?,
) -> Bool {
  match result {
    None => false
    Some(ty) =>
      match ty {
        String_ => not(self.opts.use_js_string_builtins)
        Id(id) => {
          let typedef = self.resolve.types[id]
          match typedef.kind {
            List(_) | Record(_) | Variant(_) | Option(_) => true
            Result(ok~, err~) =>
              match (ok, err) {
                (None, None) => false
                _ => true
              }
            // Flags can fit in a single i32, no need for retptr
            Flags(_) | Enum(_) => false
            _ => false
          }
        }
        _ => false
      }
  }
}

///|
/// Generate lift code for a parameter
fn Generator::generate_param_lift(
  self : Generator,
  name : String,
  ty : @resolve.Type,
) -> String {
  match ty {
    String_ =>
      if self.opts.use_js_string_builtins {
        "" // No lift needed - String passed directly
      } else {
        "let " +
        name +
        " = @cabi.cabi_lift_string(" +
        name +
        "_ptr, " +
        name +
        "_len)"
      }
    Id(id) => {
      let typedef = self.resolve.types[id]
      match typedef.kind {
        Flags(_) => {
          let type_name = self.resolve_type_name(id)
          "let " + name + " = " + type_name + "::from_bits(" + name + ")"
        }
        Enum(_) => {
          let type_name = self.resolve_type_name(id)
          "let " +
          name +
          " : " +
          type_name +
          " = " +
          type_name +
          "::from_ordinal(" +
          name +
          ")"
        }
        List(inner) => {
          let elem_size = self.type_size(inner)
          let list_type = self.resolve_type_name(id)
          let sb = StringBuilder::new()
          sb.write_string("let ")
          sb.write_string(name)
          sb.write_string(" : ")
          sb.write_string(list_type)
          sb.write_string(" = {\n")
          sb.write_string("    let arr : ")
          sb.write_string(list_type)
          sb.write_string(" = Array::new(capacity=")
          sb.write_string(name)
          sb.write_string("_len)\n")
          sb.write_string("    for i = 0; i < ")
          sb.write_string(name)
          sb.write_string("_len; i = i + 1 {\n")
          sb.write_string("      let elem_ptr = ")
          sb.write_string(name)
          sb.write_string("_ptr + i * ")
          sb.write_string(elem_size.to_string())
          sb.write_string("\n")
          sb.write_string("      arr.push(")
          sb.write_string(self.generate_list_elem_lift(inner, "elem_ptr"))
          sb.write_string(")\n")
          sb.write_string("    }\n")
          sb.write_string("    arr\n")
          sb.write_string("  }")
          sb.to_string()
        }
        Record(fields) => {
          // Lift record from linear memory
          let type_name = self.resolve_type_name(id)
          let sb = StringBuilder::new()
          sb.write_string("let ")
          sb.write_string(name)
          sb.write_string(" : ")
          sb.write_string(type_name)
          sb.write_string(" = {\n")
          let mut offset = 0
          for field in fields {
            let field_name = to_snake_case(field.name)
            sb.write_string("    ")
            sb.write_string(field_name)
            sb.write_string(": ")
            sb.write_string(
              self.generate_field_lift(name + "_ptr", offset, field.field_type),
            )
            sb.write_string(",\n")
            offset = offset + self.type_size(field.field_type)
          }
          sb.write_string("  }")
          sb.to_string()
        }
        Variant(cases) => {
          // Lift variant from linear memory (discriminant + payload)
          let type_name = self.resolve_type_name(id)
          let sb = StringBuilder::new()
          sb.write_string("let ")
          sb.write_string(name)
          sb.write_string(" : ")
          sb.write_string(type_name)
          sb.write_string(" = match @cabi.cabi_read_i32(")
          sb.write_string(name)
          sb.write_string("_ptr) {\n")
          for i, case in cases {
            sb.write_string("    ")
            sb.write_string(i.to_string())
            sb.write_string(" => ")
            sb.write_string(to_pascal_case(case.name))
            match case.case_type {
              Some(payload_ty) => {
                sb.write_string("(")
                sb.write_string(
                  self.generate_field_lift(name + "_ptr + 4", 0, payload_ty),
                )
                sb.write_string(")")
              }
              None => ()
            }
            sb.write_string("\n")
          }
          sb.write_string("    _ => abort(\"invalid variant discriminant\")\n")
          sb.write_string("  }")
          sb.to_string()
        }
        _ => ""
      }
    }
    _ => ""
  }
}

///|
/// Generate lift code for a single field
fn Generator::generate_field_lift(
  self : Generator,
  base_ptr : String,
  offset : Int,
  ty : @resolve.Type,
) -> String {
  let offset_str = if offset == 0 {
    base_ptr
  } else {
    base_ptr + " + " + offset.to_string()
  }
  match ty {
    Bool => "@cabi.cabi_read_i32(" + offset_str + ") != 0"
    U8 | S8 => "@cabi.cabi_read_u8(" + offset_str + ").to_int()" // byte access
    U16 | S16 => "@cabi.cabi_read_i32(" + offset_str + ") & 0xffff"
    U32 | S32 => "@cabi.cabi_read_i32(" + offset_str + ")"
    U64 => "@cabi.cabi_read_i64(" + offset_str + ").reinterpret_as_uint64()"
    S64 => "@cabi.cabi_read_i64(" + offset_str + ")"
    F32 => "@cabi.cabi_read_f32(" + offset_str + ")"
    F64 => "@cabi.cabi_read_f64(" + offset_str + ")"
    Char => "@cabi.cabi_read_i32(" + offset_str + ").unsafe_to_char()"
    String_ =>
      "@cabi.cabi_lift_string(@cabi.cabi_read_i32(" +
      offset_str +
      "), @cabi.cabi_read_i32(" +
      offset_str +
      " + 4))"
    Id(id) => {
      let typedef = self.resolve.types[id]
      match typedef.kind {
        Record(fields) => {
          // Generate inline record lift using explicit constructor
          let type_name = self.resolve_type_name(id)
          let sb = StringBuilder::new()
          sb.write_string("(")
          sb.write_string("{ ")
          for i, field in fields {
            if i > 0 {
              sb.write_string(", ")
            }
            let field_name = to_snake_case(field.name)
            let mut field_offset = 0
            // Calculate offset for this field
            for j = 0; j < i; j = j + 1 {
              field_offset = field_offset + self.type_size(fields[j].field_type)
            }
            sb.write_string(field_name)
            sb.write_string(": ")
            sb.write_string(
              self.generate_field_lift(
                offset_str,
                field_offset,
                field.field_type,
              ),
            )
          }
          sb.write_string(" } : ")
          sb.write_string(type_name)
          sb.write_string(")")
          sb.to_string()
        }
        _ => "@cabi.cabi_read_i32(" + offset_str + ") // TODO: lift nested type"
      }
    }
  }
}

///|
/// Get the lifted parameter name
fn Generator::lifted_param_name(
  self : Generator,
  name : String,
  ty : @resolve.Type,
) -> String {
  match ty {
    String_ => name
    U8 | U16 | U32 => name + ".reinterpret_as_uint()"
    U64 => name + ".reinterpret_as_uint64()"
    Char => name + ".unsafe_to_char()"
    Id(id) => {
      let typedef = self.resolve.types[id]
      match typedef.kind {
        List(_) | Flags(_) | Record(_) | Variant(_) => name
        Resource => {
          // Resource handle: wrap Int in newtype
          let type_name = self.resolve_type_name(id)
          type_name + "(" + name + ")"
        }
        Handle(handle) => {
          // Handle (own/borrow): wrap Int in resource newtype
          let res_id = match handle {
            Own(id) => id
            Borrow(id) => id
          }
          let type_name = self.resolve_type_name(res_id)
          type_name + "(" + name + ")"
        }
        _ => name
      }
    }
    _ => name
  }
}

///|
/// Compute total size of a record
fn Generator::compute_record_size(
  self : Generator,
  fields : Array[@resolve.RecordField],
) -> Int {
  let mut size = 0
  for field in fields {
    size = size + self.type_size(field.field_type)
  }
  size
}

///|
/// Generate code to lower a value to a memory location (convenience wrapper)
fn Generator::generate_field_lower(
  self : Generator,
  sb : StringBuilder,
  ptr_expr : String,
  ty : @resolve.Type,
  val_expr : String,
) -> Unit {
  self.generate_value_lower(sb, ptr_expr, ty, val_expr, "      ")
}

///|
/// Generate code to lower result and return pointer to result structure
fn Generator::generate_result_lower_indirect(
  self : Generator,
  sb : StringBuilder,
  result : @resolve.Type?,
) -> Unit {
  match result {
    None => ()
    Some(ty) =>
      match ty {
        String_ => {
          // String return: allocate 8 bytes for (ptr, len) and return pointer
          sb.write_string(
            "  let (ptr, len) = @cabi.cabi_lower_string(result)\n",
          )
          sb.write_string("  let retptr = @cabi.cabi_realloc(0, 0, 4, 8)\n")
          sb.write_string("  @cabi.cabi_write_i32(retptr, ptr)\n")
          sb.write_string("  @cabi.cabi_write_i32(retptr + 4, len)\n")
          sb.write_string("  retptr\n")
        }
        Id(id) => {
          let typedef = self.resolve.types[id]
          match typedef.kind {
            List(inner) => {
              let elem_size = self.type_size(inner)
              let elem_align = self.type_align(inner)
              sb.write_string("  // Lower list to linear memory\n")
              sb.write_string("  let len = result.length()\n")
              sb.write_string("  let elem_size = ")
              sb.write_string(elem_size.to_string())
              sb.write_string("\n")
              sb.write_string("  let ptr = @cabi.cabi_realloc(0, 0, ")
              sb.write_string(elem_align.to_string())
              sb.write_string(", len * elem_size)\n")
              sb.write_string("  for i, elem in result {\n")
              sb.write_string("    let elem_ptr = ptr + i * elem_size\n")
              self.generate_list_elem_lower(sb, inner, "elem_ptr", "elem")
              sb.write_string("  }\n")
              sb.write_string("  let retptr = @cabi.cabi_realloc(0, 0, 4, 8)\n")
              sb.write_string("  @cabi.cabi_write_i32(retptr, ptr)\n")
              sb.write_string("  @cabi.cabi_write_i32(retptr + 4, len)\n")
              sb.write_string("  retptr\n")
            }
            Option(inner) => {
              let inner_size = self.type_size(inner)
              sb.write_string("  let retptr = @cabi.cabi_realloc(0, 0, 4, 4 + ")
              sb.write_string(inner_size.to_string())
              sb.write_string(")\n")
              sb.write_string("  match result {\n")
              sb.write_string("    Some(val) => {\n")
              sb.write_string(
                "      @cabi.cabi_write_i32(retptr, 1) // discriminant: Some\n",
              )
              self.generate_field_lower(sb, "retptr + 4", inner, "val")
              sb.write_string("    }\n")
              sb.write_string(
                "    None => @cabi.cabi_write_i32(retptr, 0) // discriminant: None\n",
              )
              sb.write_string("  }\n")
              sb.write_string("  retptr\n")
            }
            Result(ok=ok_ty, err=err_ty) => {
              let ok_size = match ok_ty {
                Some(t) => self.type_size(t)
                None => 0
              }
              let err_size = match err_ty {
                Some(t) => self.type_size(t)
                None => 0
              }
              let payload_size = if ok_size > err_size {
                ok_size
              } else {
                err_size
              }
              sb.write_string("  let retptr = @cabi.cabi_realloc(0, 0, 4, 4 + ")
              sb.write_string(payload_size.to_string())
              sb.write_string(")\n")
              sb.write_string("  match result {\n")
              sb.write_string("    Ok(val) => {\n")
              sb.write_string(
                "      @cabi.cabi_write_i32(retptr, 0) // discriminant: Ok\n",
              )
              match ok_ty {
                Some(t) => self.generate_field_lower(sb, "retptr + 4", t, "val")
                None => ()
              }
              sb.write_string("    }\n")
              sb.write_string("    Err(e) => {\n")
              sb.write_string(
                "      @cabi.cabi_write_i32(retptr, 1) // discriminant: Err\n",
              )
              match err_ty {
                Some(t) => self.generate_field_lower(sb, "retptr + 4", t, "e")
                None => ()
              }
              sb.write_string("    }\n")
              sb.write_string("  }\n")
              sb.write_string("  retptr\n")
            }
            Record(fields) => {
              let record_size = self.compute_record_size(fields)
              sb.write_string("  let retptr = @cabi.cabi_realloc(0, 0, 4, ")
              sb.write_string(record_size.to_string())
              sb.write_string(")\n")
              sb.write_string("  // Lower record to linear memory\n")
              let mut offset = 0
              for field in fields {
                let field_name = to_snake_case(field.name)
                self.generate_field_lower(
                  sb,
                  "retptr + " + offset.to_string(),
                  field.field_type,
                  "result." + field_name,
                )
                offset = offset + self.type_size(field.field_type)
              }
              sb.write_string("  retptr\n")
            }
            Variant(_) => {
              sb.write_string("  // TODO: lower variant to linear memory\n")
              sb.write_string("  0\n")
            }
            _ => {
              sb.write_string("  // TODO: lower complex type\n")
              sb.write_string("  0\n")
            }
          }
        }
        _ => ()
      }
  }
}
