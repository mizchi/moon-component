/// MoonBit code generator for WIT

///|
/// Package format for generated files
pub(all) enum PkgFormat {
  /// moon.pkg.json (JSON format)
  Json
  /// moon.pkg (MoonBit DSL format)
  Dsl
} derive(Show, Eq)

///|
/// Generator options
pub(all) struct GeneratorOpts {
  trait_exports : Bool
  out_dir : String?
  project_name : String?
  gen_dir : String
  impl_dir : String
  generate_impl : Bool
  generate_wkg : Bool
  wkg_version : String
  pkg_format : PkgFormat
  use_js_string_builtins : Bool
} derive(Show)

///|
pub fn GeneratorOpts::default() -> GeneratorOpts {
  {
    trait_exports: true,
    out_dir: None,
    project_name: None,
    gen_dir: "gen",
    impl_dir: "impl",
    generate_impl: true,
    generate_wkg: false,
    wkg_version: "0.1.0",
    pkg_format: Json,
    use_js_string_builtins: false,
  }
}

///|
/// Generated file
pub struct GeneratedFile {
  path : String
  content : String
  is_stub : Bool // stub files should not overwrite existing
} derive(Show)

///|
/// Export info for impl entry point generation
pub struct ExportInfo {
  func_name : String // e.g., "wasmExportGreet"
  wit_name : String // e.g., "local:hello/greet#greet"
  ffi_params : Array[String] // e.g., ["p0_ptr : Int", "p0_len : Int"]
  ffi_return_type : String // e.g., "Int", "Unit", "Float"
  returns_indirect : Bool // true if returns via retptr
} derive(Show)

///|
/// Code generator
pub struct Generator {
  opts : GeneratorOpts
  resolve : @resolve.Resolve
  world_id : Int
  output : Array[GeneratedFile]
  exports_info : Array[ExportInfo]
}

///|
pub fn Generator::new(
  resolve : @resolve.Resolve,
  world_id : Int,
  opts : GeneratorOpts,
) -> Generator {
  { opts, resolve, world_id, output: [], exports_info: [] }
}

///|
/// Generate all files
pub fn Generator::generate(self : Generator) -> Array[GeneratedFile] {
  let world = self.resolve.worlds[self.world_id]

  // Generate canonical ABI helpers
  self.generate_cabi()

  // Generate exports
  for _, item in world.exports {
    match item {
      Interface(iref) => self.generate_interface_export(iref.id)
      Function(_) => () // TODO: world-level functions
    }
  }

  // Generate imports
  for _, item in world.imports {
    match item {
      Interface(iref) => self.generate_interface_import(iref.id)
      Function(_) => () // TODO
    }
  }

  // Generate wkg.toml if requested
  if self.opts.generate_wkg {
    self.generate_wkg_toml(world)
  }

  // Generate impl/moon.pkg.json
  self.generate_impl_pkg()
  self.output
}

///|
/// Generate canonical ABI helpers (cabi.mbt)
fn Generator::generate_cabi(self : Generator) -> Unit {
  let sb = StringBuilder::new()
  sb.write_string(
    "// Canonical ABI helpers - Generated by moon-component\n\n",
  )

  // Inline wasm intrinsics for direct linear memory access
  sb.write_string("///| Load byte from linear memory (i32.load8_u)\n")
  sb.write_string("extern \"wasm\" fn mem_load8(ptr : Int) -> Int =\n")
  sb.write_string(
    "  #|(func (param i32) (result i32) (i32.load8_u (local.get 0)))\n\n",
  )
  sb.write_string("///| Store byte to linear memory (i32.store8)\n")
  sb.write_string(
    "extern \"wasm\" fn mem_store8(ptr : Int, val : Int) -> Unit =\n",
  )
  sb.write_string(
    "  #|(func (param i32 i32) (result i32) (i32.store8 (local.get 0) (local.get 1)) (i32.const 0))\n\n",
  )
  sb.write_string("///| Load i32 from linear memory (i32.load)\n")
  sb.write_string("extern \"wasm\" fn mem_load32(ptr : Int) -> Int =\n")
  sb.write_string(
    "  #|(func (param i32) (result i32) (i32.load (local.get 0)))\n\n",
  )
  sb.write_string("///| Store i32 to linear memory (i32.store)\n")
  sb.write_string(
    "extern \"wasm\" fn mem_store32(ptr : Int, val : Int) -> Unit =\n",
  )
  sb.write_string(
    "  #|(func (param i32 i32) (result i32) (i32.store (local.get 0) (local.get 1)) (i32.const 0))\n\n",
  )
  sb.write_string("///| Load i64 from linear memory (i64.load)\n")
  sb.write_string("extern \"wasm\" fn mem_load64(ptr : Int) -> Int64 =\n")
  sb.write_string(
    "  #|(func (param i32) (result i64) (i64.load (local.get 0)))\n\n",
  )
  sb.write_string("///| Store i64 to linear memory (i64.store)\n")
  sb.write_string(
    "extern \"wasm\" fn mem_store64(ptr : Int, val : Int64) -> Unit =\n",
  )
  sb.write_string(
    "  #|(func (param i32 i64) (result i32) (i64.store (local.get 0) (local.get 1)) (i32.const 0))\n\n",
  )
  sb.write_string("///| Load f32 from linear memory (f32.load)\n")
  sb.write_string("extern \"wasm\" fn mem_load_f32(ptr : Int) -> Float =\n")
  sb.write_string(
    "  #|(func (param i32) (result f32) (f32.load (local.get 0)))\n\n",
  )
  sb.write_string("///| Store f32 to linear memory (f32.store)\n")
  sb.write_string(
    "extern \"wasm\" fn mem_store_f32(ptr : Int, val : Float) -> Unit =\n",
  )
  sb.write_string(
    "  #|(func (param i32 f32) (result i32) (f32.store (local.get 0) (local.get 1)) (i32.const 0))\n\n",
  )
  sb.write_string("///| Load f64 from linear memory (f64.load)\n")
  sb.write_string("extern \"wasm\" fn mem_load_f64(ptr : Int) -> Double =\n")
  sb.write_string(
    "  #|(func (param i32) (result f64) (f64.load (local.get 0)))\n\n",
  )
  sb.write_string("///| Store f64 to linear memory (f64.store)\n")
  sb.write_string(
    "extern \"wasm\" fn mem_store_f64(ptr : Int, val : Double) -> Unit =\n",
  )
  sb.write_string(
    "  #|(func (param i32 f64) (result i32) (f64.store (local.get 0) (local.get 1)) (i32.const 0))\n\n",
  )
  sb.write_string("///| Get current memory size in pages (memory.size)\n")
  sb.write_string("extern \"wasm\" fn mem_size() -> Int =\n")
  sb.write_string("  #|(func (result i32) (memory.size))\n\n")
  sb.write_string("///| Grow memory by pages (memory.grow)\n")
  sb.write_string("extern \"wasm\" fn mem_grow(pages : Int) -> Int =\n")
  sb.write_string(
    "  #|(func (param i32) (result i32) (memory.grow (local.get 0)))\n\n",
  )

  // Current allocation offset - stored in a known location in linear memory
  // We use the first 4 bytes of linear memory to store the heap pointer
  sb.write_string("///| Heap base address (skip first 64KB for safety)\n")
  sb.write_string("let heap_base : Int = 65536\n\n")
  sb.write_string("///| Get current heap offset\n")
  sb.write_string("fn get_heap_offset() -> Int {\n")
  sb.write_string("  mem_load32(0)\n")
  sb.write_string("}\n\n")
  sb.write_string("///| Set heap offset\n")
  sb.write_string("fn set_heap_offset(offset : Int) -> Unit {\n")
  sb.write_string("  mem_store32(0, offset)\n")
  sb.write_string("}\n\n")
  sb.write_string("///| Initialize heap if needed\n")
  sb.write_string("fn ensure_heap_init() -> Unit {\n")
  sb.write_string("  if get_heap_offset() == 0 {\n")
  sb.write_string("    set_heap_offset(heap_base)\n")
  sb.write_string("  }\n")
  sb.write_string("}\n\n")

  // cabi_realloc implementation using linear memory
  sb.write_string("///| Canonical ABI realloc function\n")
  sb.write_string("///| Called by host to allocate memory for passing data\n")
  sb.write_string("pub fn cabi_realloc(\n")
  sb.write_string("  _old_ptr : Int,\n")
  sb.write_string("  _old_size : Int,\n")
  sb.write_string("  align : Int,\n")
  sb.write_string("  new_size : Int,\n")
  sb.write_string(") -> Int {\n")
  sb.write_string("  ensure_heap_init()\n")
  sb.write_string("  let offset = get_heap_offset()\n")
  sb.write_string("  // Align offset\n")
  sb.write_string("  let aligned = (offset + align - 1) & -(align)\n")
  sb.write_string("  let new_offset = aligned + new_size\n")
  sb.write_string("  // Grow memory if needed (64KB pages)\n")
  sb.write_string("  let pages_needed = (new_offset + 65535) / 65536\n")
  sb.write_string("  let current_pages = mem_size()\n")
  sb.write_string("  if pages_needed > current_pages {\n")
  sb.write_string(
    "    let grow_result = mem_grow(pages_needed - current_pages)\n",
  )
  sb.write_string("    if grow_result == -1 {\n")
  sb.write_string("      abort(\"cabi_realloc: memory grow failed\")\n")
  sb.write_string("    }\n")
  sb.write_string("  }\n")
  sb.write_string("  set_heap_offset(new_offset)\n")
  sb.write_string("  aligned\n")
  sb.write_string("}\n\n")

  // Reset allocator (for testing/debugging)
  sb.write_string("///| Reset the allocator (useful between calls)\n")
  sb.write_string("pub fn cabi_reset() -> Unit {\n")
  sb.write_string("  set_heap_offset(heap_base)\n")
  sb.write_string("}\n\n")

  // String lifting (ptr+len -> String)
  sb.write_string("///| Lift a string from linear memory\n")
  sb.write_string("pub fn cabi_lift_string(ptr : Int, len : Int) -> String {\n")
  sb.write_string("  let bytes : Array[Byte] = Array::new(capacity=len)\n")
  sb.write_string("  for i in 0..<len {\n")
  sb.write_string("    bytes.push(mem_load8(ptr + i).to_byte())\n")
  sb.write_string("  }\n")
  sb.write_string("  @utf8.decode_lossy(Bytes::from_array(bytes[:])[:])\n")
  sb.write_string("}\n\n")

  // String lowering (String -> writes to memory, returns ptr)
  sb.write_string("///| Lower a string to linear memory, returns (ptr, len)\n")
  sb.write_string("pub fn cabi_lower_string(s : String) -> (Int, Int) {\n")
  sb.write_string("  let bytes = @utf8.encode(s)\n")
  sb.write_string("  let len = bytes.length()\n")
  sb.write_string("  let ptr = cabi_realloc(0, 0, 1, len)\n")
  sb.write_string("  for i in 0..<len {\n")
  sb.write_string("    mem_store8(ptr + i, bytes[i].to_int())\n")
  sb.write_string("  }\n")
  sb.write_string("  (ptr, len)\n")
  sb.write_string("}\n\n")

  // Read/write primitives for linear memory (wrapper functions)
  sb.write_string("///| Read i32 from linear memory\n")
  sb.write_string("pub fn cabi_read_i32(ptr : Int) -> Int {\n")
  sb.write_string("  mem_load32(ptr)\n")
  sb.write_string("}\n\n")
  sb.write_string("///| Write i32 to linear memory\n")
  sb.write_string("pub fn cabi_write_i32(ptr : Int, val : Int) -> Unit {\n")
  sb.write_string("  mem_store32(ptr, val)\n")
  sb.write_string("}\n\n")

  // u8 read/write
  sb.write_string("///| Read u8 from linear memory\n")
  sb.write_string("pub fn cabi_read_u8(ptr : Int) -> Byte {\n")
  sb.write_string("  mem_load8(ptr).to_byte()\n")
  sb.write_string("}\n\n")
  sb.write_string("///| Write u8 to linear memory\n")
  sb.write_string("pub fn cabi_write_u8(ptr : Int, val : Byte) -> Unit {\n")
  sb.write_string("  mem_store8(ptr, val.to_int())\n")
  sb.write_string("}\n\n")

  // i64 read/write
  sb.write_string("///| Read i64 from linear memory\n")
  sb.write_string("pub fn cabi_read_i64(ptr : Int) -> Int64 {\n")
  sb.write_string("  mem_load64(ptr)\n")
  sb.write_string("}\n\n")
  sb.write_string("///| Write i64 to linear memory\n")
  sb.write_string("pub fn cabi_write_i64(ptr : Int, val : Int64) -> Unit {\n")
  sb.write_string("  mem_store64(ptr, val)\n")
  sb.write_string("}\n\n")

  // f32 read/write
  sb.write_string("///| Read f32 from linear memory\n")
  sb.write_string("pub fn cabi_read_f32(ptr : Int) -> Float {\n")
  sb.write_string("  mem_load_f32(ptr)\n")
  sb.write_string("}\n\n")
  sb.write_string("///| Write f32 to linear memory\n")
  sb.write_string("pub fn cabi_write_f32(ptr : Int, val : Float) -> Unit {\n")
  sb.write_string("  mem_store_f32(ptr, val)\n")
  sb.write_string("}\n\n")

  // f64 read/write
  sb.write_string("///| Read f64 from linear memory\n")
  sb.write_string("pub fn cabi_read_f64(ptr : Int) -> Double {\n")
  sb.write_string("  mem_load_f64(ptr)\n")
  sb.write_string("}\n\n")
  sb.write_string("///| Write f64 to linear memory\n")
  sb.write_string("pub fn cabi_write_f64(ptr : Int, val : Double) -> Unit {\n")
  sb.write_string("  mem_store_f64(ptr, val)\n")
  sb.write_string("}\n\n")

  // Flags read/write (as u32 bitmask)
  sb.write_string("///| Read flags bitmask from linear memory\n")
  sb.write_string("pub fn cabi_read_flags(ptr : Int) -> Int {\n")
  sb.write_string("  mem_load32(ptr)\n")
  sb.write_string("}\n\n")
  sb.write_string("///| Write flags bitmask to linear memory\n")
  sb.write_string("pub fn cabi_write_flags(ptr : Int, val : Int) -> Unit {\n")
  sb.write_string("  mem_store32(ptr, val)\n")
  sb.write_string("}\n")
  let path = match self.opts.out_dir {
    Some(out) => out + "/" + self.opts.gen_dir + "/cabi/cabi.mbt"
    None => self.opts.gen_dir + "/cabi/cabi.mbt"
  }
  self.output.push({ path, content: sb.to_string(), is_stub: false })

  // Generate moon.pkg (JSON or DSL format)
  self.generate_cabi_pkg()
}

///|
fn Generator::generate_cabi_pkg(self : Generator) -> Unit {
  let sb = StringBuilder::new()
  let filename = match self.opts.pkg_format {
    Json => {
      sb.write_string("{\n")
      sb.write_string("  \"import\": [\n")
      sb.write_string("    \"moonbitlang/core/encoding/utf8\"\n")
      sb.write_string("  ],\n")
      sb.write_string("  \"link\": {\n")
      sb.write_string("    \"wasm\": {\n")
      sb.write_string("      \"exports\": [\n")
      sb.write_string("        \"cabi_realloc:cabi_realloc\"\n")
      sb.write_string("      ]\n")
      sb.write_string("    },\n")
      sb.write_string("    \"wasm-gc\": {\n")
      sb.write_string("      \"exports\": [\n")
      sb.write_string("        \"cabi_realloc:cabi_realloc\"\n")
      sb.write_string("      ]\n")
      sb.write_string("    }\n")
      sb.write_string("  }\n")
      sb.write_string("}\n")
      "moon.pkg.json"
    }
    Dsl => {
      sb.write_string("import(\n")
      sb.write_string("  \"moonbitlang/core/encoding/utf8\",\n")
      sb.write_string(")\n\n")
      sb.write_string("options(\n")
      sb.write_string("  link: {\n")
      sb.write_string("    \"wasm\": {\n")
      sb.write_string("      \"exports\": [\n")
      sb.write_string("        \"cabi_realloc:cabi_realloc\",\n")
      sb.write_string("      ],\n")
      sb.write_string("    },\n")
      sb.write_string("    \"wasm-gc\": {\n")
      sb.write_string("      \"exports\": [\n")
      sb.write_string("        \"cabi_realloc:cabi_realloc\",\n")
      sb.write_string("      ],\n")
      sb.write_string("    },\n")
      sb.write_string("  },\n")
      sb.write_string(")\n")
      "moon.pkg"
    }
  }
  let path = match self.opts.out_dir {
    Some(out) => out + "/" + self.opts.gen_dir + "/cabi/" + filename
    None => self.opts.gen_dir + "/cabi/" + filename
  }
  self.output.push({ path, content: sb.to_string(), is_stub: false })
}

///|
fn Generator::generate_interface_export(self : Generator, id : Int) -> Unit {
  let iface = self.resolve.interfaces[id]
  let unnamed = "unnamed"
  let iface_name = iface.name.unwrap_or(unnamed)
  let pkg = iface.pkg.map(fn(pid) { self.resolve.packages[pid] })
  let sb = StringBuilder::new()

  // Header
  sb.write_string("// Generated by moon-component\n")
  sb.write_string("// DO NOT EDIT - this file is regenerated\n\n")

  // Generate type definitions for this interface
  for _, type_id in iface.types {
    self.generate_type_def(sb, type_id)
  }

  // Trait definition
  sb.write_string("/// Export trait for ")
  sb.write_string(iface_name)
  sb.write_string("\npub(open) trait Exports {\n")
  for _, func in iface.functions {
    let sig = self.function_trait_sig(func)
    sb.write_string("  ")
    sb.write_string(sig)
    sb.write_string("\n")
  }
  sb.write_string("}\n\n")

  // Register function
  sb.write_string("let exports_impl : Ref[&Exports?] = { val: None }\n\n")
  sb.write_string("pub fn register(impl_ : &Exports) -> Unit {\n")
  sb.write_string("  exports_impl.val = Some(impl_)\n")
  sb.write_string("}\n\n")
  sb.write_string("fn get_exports() -> &Exports {\n")
  sb.write_string("  guard exports_impl.val is Some(impl_) else {\n")
  sb.write_string("    abort(\"exports not registered\")\n")
  sb.write_string("  }\n")
  sb.write_string("  impl_\n")
  sb.write_string("}\n\n")

  // cabi_realloc re-export
  sb.write_string("///| Re-export cabi_realloc for wasm linking\n")
  sb.write_string("pub fn cabi_realloc(\n")
  sb.write_string("  old_ptr : Int,\n")
  sb.write_string("  old_size : Int,\n")
  sb.write_string("  align : Int,\n")
  sb.write_string("  new_size : Int,\n")
  sb.write_string(") -> Int {\n")
  sb.write_string("  @cabi.cabi_realloc(old_ptr, old_size, align, new_size)\n")
  sb.write_string("}\n\n")

  // FFI export wrappers
  let exports : Array[(String, String, Array[String], String, Bool)] = []
  for _, func in iface.functions {
    let export_info = self.generate_ffi_export(sb, func, iface_name, pkg)
    exports.push(export_info)
  }

  // Main function (required for is-main package)
  sb.write_string("///|\nfn main {\n  ()\n}\n")

  // Output to impl/bindings.mbt
  let path = self.impl_path("bindings.mbt")
  self.output.push({ path, content: sb.to_string(), is_stub: false })

  // Collect export info for moon.pkg.json generation
  for exp in exports {
    let (func_name, wit_name, ffi_params, ffi_return_type, returns_indirect) = exp
    self.exports_info.push({
      func_name,
      wit_name,
      ffi_params,
      ffi_return_type,
      returns_indirect,
    })
  }

  // Generate impl/impl.mbt (user implementation)
  if self.opts.generate_impl {
    self.generate_impl(id, iface_name, iface)
  }
}

///|
/// Returns (func_name, wit_name, ffi_params, ffi_return_type, returns_indirect)
fn Generator::generate_ffi_export(
  self : Generator,
  sb : StringBuilder,
  func : @resolve.Function,
  iface_name : String,
  pkg : @resolve.Package?,
) -> (String, String, Array[String], String, Bool) {
  let normalized_name = normalize_func_name(func.name, func.kind)
  let export_name = to_camel_case(normalized_name)
  let func_name = "wasmExport" + export_name
  // Build WIT export name for moon.pkg.json
  let wit_export_name = match pkg {
    Some(p) =>
      p.name.ns + ":" + p.name.name + "/" + iface_name + "#" + func.name
    None => iface_name + "#" + func.name
  }
  sb.write_string("pub fn ")
  sb.write_string(func_name)
  sb.write_string("(")

  // Parameters - String becomes (ptr, len)
  // Rename 'self' to 'handle' to avoid being interpreted as a method
  let ffi_params : Array[String] = []
  for param in func.params {
    let (pname, ptype) = param
    let snake_name = to_snake_case(pname)
    let safe_name = if snake_name == "self" { "handle" } else { snake_name }
    let ffi_param = self.type_to_ffi_params(safe_name, ptype)
    for p in ffi_param {
      ffi_params.push(p)
    }
  }
  sb.write_string(ffi_params.join(", "))

  // Return type - complex types return pointer to (ptr, len) structure
  let returns_indirect = self.type_returns_multivalue(func.result)
  let ffi_return_type = if returns_indirect {
    "Int" // Pointer to result structure in linear memory
  } else {
    self.result_to_ffi(func.result)
  }
  sb.write_string(") -> ")
  sb.write_string(ffi_return_type)
  sb.write_string(" {\n")

  // Lift parameters
  for param in func.params {
    let (pname, ptype) = param
    let snake_name = to_snake_case(pname)
    let safe_name = if snake_name == "self" { "handle" } else { snake_name }
    let lift = self.generate_param_lift(safe_name, ptype)
    if lift.length() > 0 {
      sb.write_string("  ")
      sb.write_string(lift)
      sb.write_string("\n")
    }
  }

  // Call trait method
  let call_args : Array[String] = []
  for param in func.params {
    let (pname, ptype) = param
    let snake_name = to_snake_case(pname)
    let safe_name = if snake_name == "self" { "handle" } else { snake_name }
    call_args.push(self.lifted_param_name(safe_name, ptype))
  }
  if returns_indirect {
    // Complex return: allocate result structure and return pointer
    sb.write_string("  let result = get_exports().")
    sb.write_string(normalized_name)
    sb.write_string("(")
    sb.write_string(call_args.join(", "))
    sb.write_string(")\n")
    self.generate_result_lower_indirect(sb, func.result)
  } else {
    // Simple return
    let result_conv = self.ffi_to_type_conv(func.result)
    sb.write_string("  ")
    if result_conv.0.length() > 0 {
      sb.write_string(result_conv.0)
    }
    sb.write_string("get_exports().")
    sb.write_string(normalized_name)
    sb.write_string("(")
    sb.write_string(call_args.join(", "))
    sb.write_string(")")
    sb.write_string(result_conv.1)
    sb.write_string("\n")
  }
  sb.write_string("}\n\n")
  (func_name, wit_export_name, ffi_params, ffi_return_type, returns_indirect)
}

///|
/// Check if return type needs multi-value return (via retptr)
fn Generator::type_returns_multivalue(
  self : Generator,
  result : @resolve.Type?,
) -> Bool {
  match result {
    None => false
    Some(ty) =>
      match ty {
        String_ => not(self.opts.use_js_string_builtins)
        Id(id) => {
          let typedef = self.resolve.types[id]
          match typedef.kind {
            List(_)
            | Record(_)
            | Variant(_)
            | Result(ok=_, err=_)
            | Option(_) => true
            // Flags can fit in a single i32, no need for retptr
            Flags(_) | Enum(_) => false
            _ => false
          }
        }
        _ => false
      }
  }
}

///|
/// Generate FFI parameter list (String becomes ptr + len)
fn Generator::type_to_ffi_params(
  self : Generator,
  name : String,
  ty : @resolve.Type,
) -> Array[String] {
  match ty {
    String_ =>
      if self.opts.use_js_string_builtins {
        [name + " : String"]
      } else {
        [name + "_ptr : Int", name + "_len : Int"]
      }
    Id(id) => {
      let typedef = self.resolve.types[id]
      match typedef.kind {
        List(_) => [name + "_ptr : Int", name + "_len : Int"]
        Record(_) | Variant(_) => [name + "_ptr : Int"]
        Flags(_) => [name + " : Int"] // bitmask
        _ => [name + " : " + self.type_to_ffi(ty)]
      }
    }
    _ => [name + " : " + self.type_to_ffi(ty)]
  }
}

///|
/// Generate lift code for a parameter
fn Generator::generate_param_lift(
  self : Generator,
  name : String,
  ty : @resolve.Type,
) -> String {
  match ty {
    String_ =>
      if self.opts.use_js_string_builtins {
        "" // No lift needed - String passed directly
      } else {
        "let " +
        name +
        " = @cabi.cabi_lift_string(" +
        name +
        "_ptr, " +
        name +
        "_len)"
      }
    Id(id) => {
      let typedef = self.resolve.types[id]
      match typedef.kind {
        Flags(_) => {
          let type_name = self.resolve_type_name(id)
          "let " + name + " = " + type_name + "::from_bits(" + name + ")"
        }
        Enum(_) => {
          let type_name = self.resolve_type_name(id)
          "let " +
          name +
          " : " +
          type_name +
          " = " +
          type_name +
          "::from_ordinal(" +
          name +
          ")"
        }
        List(inner) => {
          let elem_size = self.type_size(inner)
          let list_type = self.resolve_type_name(id)
          let sb = StringBuilder::new()
          sb.write_string("let ")
          sb.write_string(name)
          sb.write_string(" : ")
          sb.write_string(list_type)
          sb.write_string(" = {\n")
          sb.write_string("    let arr : ")
          sb.write_string(list_type)
          sb.write_string(" = Array::new(capacity=")
          sb.write_string(name)
          sb.write_string("_len)\n")
          sb.write_string("    for i = 0; i < ")
          sb.write_string(name)
          sb.write_string("_len; i = i + 1 {\n")
          sb.write_string("      let elem_ptr = ")
          sb.write_string(name)
          sb.write_string("_ptr + i * ")
          sb.write_string(elem_size.to_string())
          sb.write_string("\n")
          sb.write_string("      arr.push(")
          sb.write_string(self.generate_list_elem_lift(inner, "elem_ptr"))
          sb.write_string(")\n")
          sb.write_string("    }\n")
          sb.write_string("    arr\n")
          sb.write_string("  }")
          sb.to_string()
        }
        Record(fields) => {
          // Lift record from linear memory
          let type_name = self.resolve_type_name(id)
          let sb = StringBuilder::new()
          sb.write_string("let ")
          sb.write_string(name)
          sb.write_string(" : ")
          sb.write_string(type_name)
          sb.write_string(" = {\n")
          let mut offset = 0
          for field in fields {
            let field_name = to_snake_case(field.name)
            sb.write_string("    ")
            sb.write_string(field_name)
            sb.write_string(": ")
            sb.write_string(
              self.generate_field_lift(name + "_ptr", offset, field.field_type),
            )
            sb.write_string(",\n")
            offset = offset + self.type_size(field.field_type)
          }
          sb.write_string("  }")
          sb.to_string()
        }
        Variant(cases) => {
          // Lift variant from linear memory (discriminant + payload)
          let type_name = self.resolve_type_name(id)
          let sb = StringBuilder::new()
          sb.write_string("let ")
          sb.write_string(name)
          sb.write_string(" : ")
          sb.write_string(type_name)
          sb.write_string(" = match @cabi.cabi_read_i32(")
          sb.write_string(name)
          sb.write_string("_ptr) {\n")
          for i, case in cases {
            sb.write_string("    ")
            sb.write_string(i.to_string())
            sb.write_string(" => ")
            sb.write_string(to_pascal_case(case.name))
            match case.case_type {
              Some(payload_ty) => {
                sb.write_string("(")
                sb.write_string(
                  self.generate_field_lift(name + "_ptr + 4", 0, payload_ty),
                )
                sb.write_string(")")
              }
              None => ()
            }
            sb.write_string("\n")
          }
          sb.write_string("    _ => abort(\"invalid variant discriminant\")\n")
          sb.write_string("  }")
          sb.to_string()
        }
        _ => ""
      }
    }
    _ => ""
  }
}

///|
/// Generate lift code for a single field
fn Generator::generate_field_lift(
  self : Generator,
  base_ptr : String,
  offset : Int,
  ty : @resolve.Type,
) -> String {
  let offset_str = if offset == 0 {
    base_ptr
  } else {
    base_ptr + " + " + offset.to_string()
  }
  match ty {
    Bool => "@cabi.cabi_read_i32(" + offset_str + ") != 0"
    U8 | S8 => "@cabi.cabi_read_u8(" + offset_str + ").to_int()" // byte access
    U16 | S16 => "@cabi.cabi_read_i32(" + offset_str + ") & 0xffff"
    U32 | S32 => "@cabi.cabi_read_i32(" + offset_str + ")"
    U64 => "@cabi.cabi_read_i64(" + offset_str + ").reinterpret_as_uint64()"
    S64 => "@cabi.cabi_read_i64(" + offset_str + ")"
    F32 => "@cabi.cabi_read_f32(" + offset_str + ")"
    F64 => "@cabi.cabi_read_f64(" + offset_str + ")"
    Char => "@cabi.cabi_read_i32(" + offset_str + ").unsafe_to_char()"
    String_ =>
      "@cabi.cabi_lift_string(@cabi.cabi_read_i32(" +
      offset_str +
      "), @cabi.cabi_read_i32(" +
      offset_str +
      " + 4))"
    Id(id) => {
      let typedef = self.resolve.types[id]
      match typedef.kind {
        Record(fields) => {
          // Generate inline record lift using explicit constructor
          let type_name = self.resolve_type_name(id)
          let sb = StringBuilder::new()
          sb.write_string("(")
          sb.write_string("{ ")
          for i, field in fields {
            if i > 0 {
              sb.write_string(", ")
            }
            let field_name = to_snake_case(field.name)
            let mut field_offset = 0
            // Calculate offset for this field
            for j = 0; j < i; j = j + 1 {
              field_offset = field_offset + self.type_size(fields[j].field_type)
            }
            sb.write_string(field_name)
            sb.write_string(": ")
            sb.write_string(
              self.generate_field_lift(
                offset_str,
                field_offset,
                field.field_type,
              ),
            )
          }
          sb.write_string(" } : ")
          sb.write_string(type_name)
          sb.write_string(")")
          sb.to_string()
        }
        _ => "@cabi.cabi_read_i32(" + offset_str + ") // TODO: lift nested type"
      }
    }
  }
}

///|
/// Get the lifted parameter name
fn Generator::lifted_param_name(
  self : Generator,
  name : String,
  ty : @resolve.Type,
) -> String {
  match ty {
    String_ => name
    U8 | U16 | U32 => name + ".reinterpret_as_uint()"
    U64 => name + ".reinterpret_as_uint64()"
    Char => name + ".unsafe_to_char()"
    Id(id) => {
      let typedef = self.resolve.types[id]
      match typedef.kind {
        List(_) | Flags(_) | Record(_) | Variant(_) => name
        Resource => {
          // Resource handle: wrap Int in newtype
          let type_name = self.resolve_type_name(id)
          type_name + "(" + name + ")"
        }
        Handle(handle) => {
          // Handle (own/borrow): wrap Int in resource newtype
          let res_id = match handle {
            Own(id) => id
            Borrow(id) => id
          }
          let type_name = self.resolve_type_name(res_id)
          type_name + "(" + name + ")"
        }
        _ => name
      }
    }
    _ => name
  }
}

///|
/// Generate code to lower result and return pointer to result structure
fn Generator::generate_result_lower_indirect(
  self : Generator,
  sb : StringBuilder,
  result : @resolve.Type?,
) -> Unit {
  match result {
    None => ()
    Some(ty) =>
      match ty {
        String_ => {
          // String return: allocate 8 bytes for (ptr, len) and return pointer
          sb.write_string(
            "  let (ptr, len) = @cabi.cabi_lower_string(result)\n",
          )
          sb.write_string("  let retptr = @cabi.cabi_realloc(0, 0, 4, 8)\n")
          sb.write_string("  @cabi.cabi_write_i32(retptr, ptr)\n")
          sb.write_string("  @cabi.cabi_write_i32(retptr + 4, len)\n")
          sb.write_string("  retptr\n")
        }
        Id(id) => {
          let typedef = self.resolve.types[id]
          match typedef.kind {
            List(inner) => {
              let elem_size = self.type_size(inner)
              let elem_align = self.type_align(inner)
              sb.write_string("  // Lower list to linear memory\n")
              sb.write_string("  let len = result.length()\n")
              sb.write_string("  let elem_size = ")
              sb.write_string(elem_size.to_string())
              sb.write_string("\n")
              sb.write_string("  let ptr = @cabi.cabi_realloc(0, 0, ")
              sb.write_string(elem_align.to_string())
              sb.write_string(", len * elem_size)\n")
              sb.write_string("  for i, elem in result {\n")
              sb.write_string("    let elem_ptr = ptr + i * elem_size\n")
              self.generate_list_elem_lower(sb, inner, "elem_ptr", "elem")
              sb.write_string("  }\n")
              sb.write_string("  let retptr = @cabi.cabi_realloc(0, 0, 4, 8)\n")
              sb.write_string("  @cabi.cabi_write_i32(retptr, ptr)\n")
              sb.write_string("  @cabi.cabi_write_i32(retptr + 4, len)\n")
              sb.write_string("  retptr\n")
            }
            Option(inner) => {
              let inner_size = self.type_size(inner)
              sb.write_string("  let retptr = @cabi.cabi_realloc(0, 0, 4, 4 + ")
              sb.write_string(inner_size.to_string())
              sb.write_string(")\n")
              sb.write_string("  match result {\n")
              sb.write_string("    Some(val) => {\n")
              sb.write_string(
                "      @cabi.cabi_write_i32(retptr, 1) // discriminant: Some\n",
              )
              self.generate_field_lower(sb, "retptr + 4", inner, "val")
              sb.write_string("    }\n")
              sb.write_string(
                "    None => @cabi.cabi_write_i32(retptr, 0) // discriminant: None\n",
              )
              sb.write_string("  }\n")
              sb.write_string("  retptr\n")
            }
            Result(ok=ok_ty, err=err_ty) => {
              let ok_size = match ok_ty {
                Some(t) => self.type_size(t)
                None => 0
              }
              let err_size = match err_ty {
                Some(t) => self.type_size(t)
                None => 0
              }
              let payload_size = if ok_size > err_size {
                ok_size
              } else {
                err_size
              }
              sb.write_string("  let retptr = @cabi.cabi_realloc(0, 0, 4, 4 + ")
              sb.write_string(payload_size.to_string())
              sb.write_string(")\n")
              sb.write_string("  match result {\n")
              sb.write_string("    Ok(val) => {\n")
              sb.write_string(
                "      @cabi.cabi_write_i32(retptr, 0) // discriminant: Ok\n",
              )
              match ok_ty {
                Some(t) => self.generate_field_lower(sb, "retptr + 4", t, "val")
                None => ()
              }
              sb.write_string("    }\n")
              sb.write_string("    Err(e) => {\n")
              sb.write_string(
                "      @cabi.cabi_write_i32(retptr, 1) // discriminant: Err\n",
              )
              match err_ty {
                Some(t) => self.generate_field_lower(sb, "retptr + 4", t, "e")
                None => ()
              }
              sb.write_string("    }\n")
              sb.write_string("  }\n")
              sb.write_string("  retptr\n")
            }
            Record(fields) => {
              let record_size = self.compute_record_size(fields)
              sb.write_string("  let retptr = @cabi.cabi_realloc(0, 0, 4, ")
              sb.write_string(record_size.to_string())
              sb.write_string(")\n")
              sb.write_string("  // Lower record to linear memory\n")
              let mut offset = 0
              for field in fields {
                let field_name = to_snake_case(field.name)
                self.generate_field_lower(
                  sb,
                  "retptr + " + offset.to_string(),
                  field.field_type,
                  "result." + field_name,
                )
                offset = offset + self.type_size(field.field_type)
              }
              sb.write_string("  retptr\n")
            }
            Variant(_) => {
              sb.write_string("  // TODO: lower variant to linear memory\n")
              sb.write_string("  0\n")
            }
            _ => {
              sb.write_string("  // TODO: lower complex type\n")
              sb.write_string("  0\n")
            }
          }
        }
        _ => ()
      }
  }
}

///|
/// Compute total size of a record
fn Generator::compute_record_size(
  self : Generator,
  fields : Array[@resolve.RecordField],
) -> Int {
  let mut size = 0
  for field in fields {
    size = size + self.type_size(field.field_type)
  }
  size
}

///|
/// Generate code to lower a value to a memory location (convenience wrapper)
fn Generator::generate_field_lower(
  self : Generator,
  sb : StringBuilder,
  ptr_expr : String,
  ty : @resolve.Type,
  val_expr : String,
) -> Unit {
  self.generate_value_lower(sb, ptr_expr, ty, val_expr, "      ")
}

///|
/// Get the size of a type in bytes (for canonical ABI)
fn Generator::type_size(self : Generator, ty : @resolve.Type) -> Int {
  match ty {
    Bool | U8 | S8 => 1
    U16 | S16 => 2
    U32 | S32 | F32 | Char => 4
    U64 | S64 | F64 => 8
    String_ => 8 // ptr + len
    Id(id) => {
      let typedef = self.resolve.types[id]
      match typedef.kind {
        Record(fields) => {
          let mut size = 0
          for field in fields {
            // Align each field
            let field_align = self.type_align(field.field_type)
            size = (size + field_align - 1) & -field_align
            size = size + self.type_size(field.field_type)
          }
          size
        }
        Variant(cases) => {
          // discriminant (4 bytes) + max payload size
          let mut max_payload = 0
          for case in cases {
            match case.case_type {
              Some(t) => {
                let payload_size = self.type_size(t)
                if payload_size > max_payload {
                  max_payload = payload_size
                }
              }
              None => ()
            }
          }
          4 + max_payload
        }
        List(_) | Option(_) | Result(ok=_, err=_) => 8
        Flags(flags) =>
          // Flags are stored as u32 bitmask (up to 32 flags)
          if flags.length() <= 8 {
            1
          } else if flags.length() <= 16 {
            2
          } else {
            4
          }
        Enum(_) => 4 // discriminant only
        _ => 4
      }
    }
  }
}

///|
/// Get the alignment of a type (for canonical ABI)
fn Generator::type_align(self : Generator, ty : @resolve.Type) -> Int {
  match ty {
    Bool | U8 | S8 => 1
    U16 | S16 => 2
    U32 | S32 | F32 | Char => 4
    U64 | S64 | F64 => 8
    String_ => 4 // pointer alignment
    Id(id) => {
      let typedef = self.resolve.types[id]
      match typedef.kind {
        Record(fields) => {
          let mut max_align = 1
          for field in fields {
            let align = self.type_align(field.field_type)
            if align > max_align {
              max_align = align
            }
          }
          max_align
        }
        Variant(cases) => {
          let mut max_align = 4 // discriminant
          for case in cases {
            match case.case_type {
              Some(t) => {
                let align = self.type_align(t)
                if align > max_align {
                  max_align = align
                }
              }
              None => ()
            }
          }
          max_align
        }
        List(_) | Option(_) | Result(ok=_, err=_) => 4
        Flags(flags) =>
          if flags.length() <= 8 {
            1
          } else if flags.length() <= 16 {
            2
          } else {
            4
          }
        _ => 4
      }
    }
  }
}

///|
/// Generate code to lift a list element
fn Generator::generate_list_elem_lift(
  self : Generator,
  elem_ty : @resolve.Type,
  ptr_var : String,
) -> String {
  match elem_ty {
    Bool => "@cabi.cabi_read_u8(" + ptr_var + ") != b'\\x00'"
    U8 => "@cabi.cabi_read_u8(" + ptr_var + ")"
    S8 => "@cabi.cabi_read_u8(" + ptr_var + ").to_int()"
    U16 =>
      "(@cabi.cabi_read_i32(" + ptr_var + ") & 0xffff).reinterpret_as_uint()"
    S16 => "@cabi.cabi_read_i32(" + ptr_var + ") & 0xffff"
    U32 => "@cabi.cabi_read_i32(" + ptr_var + ").reinterpret_as_uint()"
    S32 => "@cabi.cabi_read_i32(" + ptr_var + ")"
    U64 => "@cabi.cabi_read_i64(" + ptr_var + ").reinterpret_as_uint64()"
    S64 => "@cabi.cabi_read_i64(" + ptr_var + ")"
    F32 => "@cabi.cabi_read_f32(" + ptr_var + ")"
    F64 => "@cabi.cabi_read_f64(" + ptr_var + ")"
    Char => "@cabi.cabi_read_i32(" + ptr_var + ").unsafe_to_char()"
    String_ =>
      "@cabi.cabi_lift_string(@cabi.cabi_read_i32(" +
      ptr_var +
      "), @cabi.cabi_read_i32(" +
      ptr_var +
      " + 4))"
    Id(id) => {
      let typedef = self.resolve.types[id]
      match typedef.kind {
        Record(fields) => {
          let type_name = self.resolve_type_name(id)
          let sb = StringBuilder::new()
          sb.write_string("({ ")
          for i, field in fields {
            if i > 0 {
              sb.write_string(", ")
            }
            let field_name = to_snake_case(field.name)
            let mut field_offset = 0
            for j = 0; j < i; j = j + 1 {
              let prev_align = self.type_align(fields[j].field_type)
              field_offset = (field_offset + prev_align - 1) & -prev_align
              field_offset = field_offset + self.type_size(fields[j].field_type)
            }
            sb.write_string(field_name)
            sb.write_string(": ")
            sb.write_string(
              self.generate_list_elem_lift(
                field.field_type,
                ptr_var + " + " + field_offset.to_string(),
              ),
            )
          }
          sb.write_string(" } : ")
          sb.write_string(type_name)
          sb.write_string(")")
          sb.to_string()
        }
        _ =>
          "@cabi.cabi_read_i32(" + ptr_var + ") // TODO: lift complex element"
      }
    }
  }
}

///|
/// Generate code to lower a value to memory at given pointer expression
/// Unified function for both list elements and record fields
fn Generator::generate_value_lower(
  self : Generator,
  sb : StringBuilder,
  ptr_expr : String,
  ty : @resolve.Type,
  val_expr : String,
  indent : String,
) -> Unit {
  match ty {
    Bool => {
      sb.write_string(indent)
      sb.write_string("@cabi.cabi_write_u8(")
      sb.write_string(ptr_expr)
      sb.write_string(", if ")
      sb.write_string(val_expr)
      sb.write_string(" { b'\\x01' } else { b'\\x00' })\n")
    }
    U8 | S8 => {
      sb.write_string(indent)
      sb.write_string("@cabi.cabi_write_u8(")
      sb.write_string(ptr_expr)
      sb.write_string(", ")
      sb.write_string(val_expr)
      sb.write_string(")\n")
    }
    U16 | U32 => {
      sb.write_string(indent)
      sb.write_string("@cabi.cabi_write_i32(")
      sb.write_string(ptr_expr)
      sb.write_string(", ")
      sb.write_string(val_expr)
      sb.write_string(".reinterpret_as_int())\n")
    }
    S16 | S32 => {
      sb.write_string(indent)
      sb.write_string("@cabi.cabi_write_i32(")
      sb.write_string(ptr_expr)
      sb.write_string(", ")
      sb.write_string(val_expr)
      sb.write_string(")\n")
    }
    U64 => {
      sb.write_string(indent)
      sb.write_string("@cabi.cabi_write_i64(")
      sb.write_string(ptr_expr)
      sb.write_string(", ")
      sb.write_string(val_expr)
      sb.write_string(".reinterpret_as_int64())\n")
    }
    S64 => {
      sb.write_string(indent)
      sb.write_string("@cabi.cabi_write_i64(")
      sb.write_string(ptr_expr)
      sb.write_string(", ")
      sb.write_string(val_expr)
      sb.write_string(")\n")
    }
    F32 => {
      sb.write_string(indent)
      sb.write_string("@cabi.cabi_write_f32(")
      sb.write_string(ptr_expr)
      sb.write_string(", ")
      sb.write_string(val_expr)
      sb.write_string(")\n")
    }
    F64 => {
      sb.write_string(indent)
      sb.write_string("@cabi.cabi_write_f64(")
      sb.write_string(ptr_expr)
      sb.write_string(", ")
      sb.write_string(val_expr)
      sb.write_string(")\n")
    }
    Char => {
      sb.write_string(indent)
      sb.write_string("@cabi.cabi_write_i32(")
      sb.write_string(ptr_expr)
      sb.write_string(", ")
      sb.write_string(val_expr)
      sb.write_string(".to_int())\n")
    }
    String_ => {
      sb.write_string(indent)
      sb.write_string("let (str_ptr, str_len) = @cabi.cabi_lower_string(")
      sb.write_string(val_expr)
      sb.write_string(")\n")
      sb.write_string(indent)
      sb.write_string("@cabi.cabi_write_i32(")
      sb.write_string(ptr_expr)
      sb.write_string(", str_ptr)\n")
      sb.write_string(indent)
      sb.write_string("@cabi.cabi_write_i32(")
      sb.write_string(ptr_expr)
      sb.write_string(" + 4, str_len)\n")
    }
    Id(id) => {
      let typedef = self.resolve.types[id]
      match typedef.kind {
        Record(fields) => {
          // Lower record fields recursively
          let mut offset = 0
          for field in fields {
            let field_name = to_snake_case(field.name)
            let field_align = self.type_align(field.field_type)
            offset = (offset + field_align - 1) & -field_align
            let field_ptr = if offset == 0 {
              ptr_expr
            } else {
              ptr_expr + " + " + offset.to_string()
            }
            self.generate_value_lower(
              sb,
              field_ptr,
              field.field_type,
              val_expr + "." + field_name,
              indent,
            )
            offset = offset + self.type_size(field.field_type)
          }
        }
        _ => {
          sb.write_string(indent)
          sb.write_string("// TODO: lower nested type ")
          sb.write_string(val_expr)
          sb.write_string("\n")
        }
      }
    }
  }
}

///|
/// Generate code to lower a list element (convenience wrapper)
fn Generator::generate_list_elem_lower(
  self : Generator,
  sb : StringBuilder,
  elem_ty : @resolve.Type,
  ptr_var : String,
  elem_var : String,
) -> Unit {
  self.generate_value_lower(sb, ptr_var, elem_ty, elem_var, "    ")
}

///|
fn Generator::ffi_to_type_conv(
  self : Generator,
  result : @resolve.Type?,
) -> (String, String) {
  // Returns (prefix, suffix) for converting result back to FFI type
  match result {
    None => ("", "")
    Some(ty) =>
      match ty {
        U8 => ("", ".to_int()")
        U16 | U32 => ("", ".reinterpret_as_int()")
        U64 => ("", ".reinterpret_as_int64()")
        Char => ("", ".to_int()")
        Id(id) => {
          let typedef = self.resolve.types[id]
          match typedef.kind {
            Flags(_) => ("", ".to_bits()")
            Enum(_) => ("", ".ordinal()") // Enum returns discriminant
            Resource => ("", ".0") // Resource handle: extract Int from newtype
            Handle(_) => ("", ".0") // Handle (own/borrow): extract Int from newtype
            _ => ("", "")
          }
        }
        _ => ("", "")
      }
  }
}

///|
fn Generator::generate_interface_import(self : Generator, id : Int) -> Unit {
  let iface = self.resolve.interfaces[id]
  let pkg = iface.pkg.map(fn(pid) { self.resolve.packages[pid] })
  let unnamed = "unnamed"
  let iface_name = iface.name.unwrap_or(unnamed)

  // Build import module name: namespace:package/interface
  let import_module = match pkg {
    Some(p) => p.name.ns + ":" + p.name.name + "/" + iface_name
    None => iface_name
  }
  let sb = StringBuilder::new()
  sb.write_string("// Generated by moon-component\n")
  sb.write_string("// Import module: ")
  sb.write_string(import_module)
  sb.write_string("\n\n")

  // Generate types first
  for _, type_id in iface.types {
    self.generate_type_def(sb, type_id)
  }

  // Collect imports for moon.pkg
  let imports : Array[(String, String, String)] = [] // (func_name, import_module, wit_func_name)
  for _, func in iface.functions {
    let func_name = to_snake_case(func.name)

    // Check if all params/result are primitive (can use direct FFI)
    let is_primitive = self.is_primitive_function(func)
    if is_primitive {
      // Direct FFI import for primitive types
      sb.write_string("///|\n")
      sb.write_string("pub fn ")
      sb.write_string(func_name)
      sb.write_string("(")
      sb.write_string(self.param_list(func.params))
      sb.write_string(") -> ")
      sb.write_string(self.result_type(func.result))
      sb.write_string(" = \"")
      sb.write_string(import_module)
      sb.write_string("\" \"")
      sb.write_string(func.name)
      sb.write_string("\"\n\n")
    } else {
      // Complex types need canonical ABI wrapper
      // Generate low-level FFI import
      let ffi_func_name = "ffi_" + func_name
      sb.write_string("///| Low-level FFI import\n")
      sb.write_string("fn ")
      sb.write_string(ffi_func_name)
      sb.write_string("(")
      sb.write_string(self.ffi_import_params(func))
      sb.write_string(") -> ")
      sb.write_string(self.ffi_import_result(func))
      sb.write_string(" = \"")
      sb.write_string(import_module)
      sb.write_string("\" \"")
      sb.write_string(func.name)
      sb.write_string("\"\n\n")

      // Generate high-level wrapper
      sb.write_string("///| High-level wrapper with canonical ABI conversion\n")
      sb.write_string("pub fn ")
      sb.write_string(func_name)
      sb.write_string("(")
      sb.write_string(self.param_list(func.params))
      sb.write_string(") -> ")
      sb.write_string(self.result_type(func.result))
      sb.write_string(" {\n")
      self.generate_import_wrapper_body(sb, func, ffi_func_name)
      sb.write_string("}\n\n")
    }
    imports.push((func_name, import_module, func.name))
  }
  let path = self.interface_path(id, "import.mbt")
  self.output.push({ path, content: sb.to_string(), is_stub: false })

  // Generate moon.pkg for import
  self.generate_import_pkg(id, imports)
}

///|
fn Generator::is_primitive_function(
  self : Generator,
  func : @resolve.Function,
) -> Bool {
  // Check all params
  for param in func.params {
    let (_, ty) = param
    if not(self.is_primitive_type(ty)) {
      return false
    }
  }
  // Check result
  match func.result {
    None => true
    Some(ty) => self.is_primitive_type(ty)
  }
}

///|
fn Generator::is_primitive_type(self : Generator, ty : @resolve.Type) -> Bool {
  match ty {
    S8 | U8 | S16 | U16 | S32 | U32 | S64 | U64 | F32 | F64 | Bool | Char =>
      true
    // With JS string builtins, string can be passed directly
    String_ => self.opts.use_js_string_builtins
    _ => false
  }
}

///|
fn Generator::ffi_import_params(
  self : Generator,
  func : @resolve.Function,
) -> String {
  let parts : Array[String] = []
  for i, param in func.params {
    let (_, ty) = param
    match ty {
      String_ =>
        if self.opts.use_js_string_builtins {
          // Direct string passing with JS string builtins
          parts.push("p" + i.to_string() + " : String")
        } else {
          // Traditional ptr+len passing
          parts.push("p" + i.to_string() + "_ptr : Int")
          parts.push("p" + i.to_string() + "_len : Int")
        }
      _ => parts.push("p" + i.to_string() + " : " + self.ffi_type(ty))
    }
  }
  // Add retptr for complex return types (string, list, etc.)
  if self.import_needs_retptr(func) {
    parts.push("retptr : Int")
  }
  parts.join(", ")
}

///|
fn Generator::import_needs_retptr(
  self : Generator,
  func : @resolve.Function,
) -> Bool {
  match func.result {
    None => false
    Some(String_) => not(self.opts.use_js_string_builtins)
    _ => false
  }
}

///|
fn Generator::ffi_import_result(
  self : Generator,
  func : @resolve.Function,
) -> String {
  match func.result {
    None => "Unit"
    Some(String_) =>
      if self.opts.use_js_string_builtins {
        "String" // Direct string return
      } else {
        // Return Int instead of Unit to work around MoonBit FFI ABI limitation
        // MoonBit generates (result i32) even for Unit returns, but Canonical ABI expects no result
        // The componentize tool will fix this by changing the import type and removing drop
        "Int"
      }
    Some(ty) => self.ffi_type(ty)
  }
}

///|
fn Generator::ffi_type(self : Generator, ty : @resolve.Type) -> String {
  match ty {
    S8 | S16 | S32 | U8 | U16 | U32 | Bool | Char => "Int"
    S64 | U64 => "Int64"
    F32 => "Float"
    F64 => "Double"
    String_ =>
      if self.opts.use_js_string_builtins {
        "String" // Direct string type
      } else {
        "Int" // ptr
      }
    _ => "Int" // fallback
  }
}

///|
fn Generator::generate_import_wrapper_body(
  self : Generator,
  sb : StringBuilder,
  func : @resolve.Function,
  ffi_func_name : String,
) -> Unit {
  // Lower arguments
  let ffi_args : Array[String] = []
  for i, param in func.params {
    let (name, ty) = param
    let var_name = to_snake_case(name)
    match ty {
      String_ =>
        if self.opts.use_js_string_builtins {
          ffi_args.push(var_name)
        } else {
          sb.write_string("  let (p")
          sb.write_string(i.to_string())
          sb.write_string("_ptr, p")
          sb.write_string(i.to_string())
          sb.write_string("_len) = @cabi.cabi_lower_string(")
          sb.write_string(var_name)
          sb.write_string(")\n")
          ffi_args.push("p" + i.to_string() + "_ptr")
          ffi_args.push("p" + i.to_string() + "_len")
        }
      U8 =>
        // Convert Byte to Int for FFI
        ffi_args.push(var_name + ".to_int()")
      U16 | U32 =>
        // Convert UInt to Int for FFI
        ffi_args.push(var_name + ".reinterpret_as_int()")
      U64 =>
        // Convert UInt64 to Int64 for FFI
        ffi_args.push(var_name + ".reinterpret_as_int64()")
      _ => ffi_args.push(var_name)
    }
  }

  // Handle string return type with retptr
  let needs_retptr = self.import_needs_retptr(func)
  if needs_retptr {
    // Allocate retptr for string result (8 bytes: ptr + len)
    sb.write_string("  let retptr = @cabi.cabi_realloc(0, 0, 4, 8)\n")
    ffi_args.push("retptr")
  }

  // Call FFI
  if needs_retptr {
    // Ignore the dummy Int return value (MoonBit FFI ABI workaround)
    sb.write_string("  let _ = ")
    sb.write_string(ffi_func_name)
    sb.write_string("(")
    sb.write_string(ffi_args.join(", "))
    sb.write_string(")\n")
  } else {
    sb.write_string("  let result = ")
    sb.write_string(ffi_func_name)
    sb.write_string("(")
    sb.write_string(ffi_args.join(", "))
    sb.write_string(")\n")
  }

  // Lift result
  match func.result {
    None => sb.write_string("  ()\n")
    Some(String_) =>
      if self.opts.use_js_string_builtins {
        sb.write_string("  result\n")
      } else {
        // Read ptr and len from retptr
        sb.write_string("  let result_ptr = @cabi.cabi_read_i32(retptr)\n")
        sb.write_string("  let result_len = @cabi.cabi_read_i32(retptr + 4)\n")
        sb.write_string("  @cabi.cabi_lift_string(result_ptr, result_len)\n")
      }
    Some(_) => sb.write_string("  result\n")
  }
}

///|
fn Generator::generate_import_pkg(
  self : Generator,
  id : Int,
  _imports : Array[(String, String, String)],
) -> Unit {
  let sb = StringBuilder::new()
  let cabi_import = self.cabi_import_path()
  let filename = match self.opts.pkg_format {
    Json => {
      sb.write_string("{\n")
      sb.write_string("  \"import\": [\n")
      sb.write_string("    { \"path\": \"")
      sb.write_string(cabi_import)
      sb.write_string("\", \"alias\": \"cabi\" }\n")
      sb.write_string("  ]\n")
      sb.write_string("}\n")
      "moon.pkg.json"
    }
    Dsl => {
      sb.write_string("import(\n")
      sb.write_string("  \"")
      sb.write_string(cabi_import)
      sb.write_string("\" as cabi,\n")
      sb.write_string(")\n")
      "moon.pkg"
    }
  }
  let path = self.interface_path(id, filename)
  self.output.push({ path, content: sb.to_string(), is_stub: false })
}

///|
fn Generator::cabi_import_path(self : Generator) -> String {
  match self.opts.project_name {
    Some(proj) => proj + "/" + self.opts.gen_dir + "/cabi"
    None => self.opts.gen_dir + "/cabi"
  }
}

///|
/// Dependency info for wkg.toml
pub struct WkgDependency {
  ns : String
  name : String
  version : String?
} derive(Show, Eq)

///|
/// Detect dependencies from world imports
fn Generator::detect_dependencies(
  self : Generator,
  world : @resolve.World,
) -> Array[WkgDependency] {
  let deps : Array[WkgDependency] = []
  let seen : Map[String, Bool] = {}

  // Get current package id
  let current_pkg_id = world.pkg

  // Scan imports for external interfaces
  for _, item in world.imports {
    match item {
      Interface(iref) => {
        let iface = self.resolve.interfaces[iref.id]
        match iface.pkg {
          Some(pkg_id) => {
            // Check if this is from a different package
            let is_external = match current_pkg_id {
              Some(curr_id) => pkg_id != curr_id
              None => true // No current package, treat all as external
            }
            if is_external {
              let pkg = self.resolve.packages[pkg_id]
              let key = pkg.name.ns + ":" + pkg.name.name
              if not(seen.contains(key)) {
                seen[key] = true
                deps.push({
                  ns: pkg.name.ns,
                  name: pkg.name.name,
                  version: pkg.name.version,
                })
              }
            }
          }
          None => ()
        }
      }
      Function(_) => ()
    }
  }
  deps
}

///|
fn Generator::generate_wkg_toml(
  self : Generator,
  world : @resolve.World,
) -> Unit {
  let sb = StringBuilder::new()

  // Get package info
  let pkg = world.pkg.map(fn(pid) { self.resolve.packages[pid] })
  let (pkg_name, pkg_ns, pkg_version) = match pkg {
    Some(p) => (p.name.name, p.name.ns, p.name.version)
    None => ("component", "local", None)
  }
  sb.write_string("[metadata]\n")
  sb.write_string("name = \"")
  sb.write_string(pkg_ns)
  sb.write_string(":")
  sb.write_string(pkg_name)
  sb.write_string("\"\n")
  sb.write_string("version = \"")
  match pkg_version {
    Some(v) => sb.write_string(v)
    None => sb.write_string(self.opts.wkg_version)
  }
  sb.write_string("\"\n")
  sb.write_string("# description = \"Your component description\"\n")
  sb.write_string("# licenses = \"MIT\"\n")
  sb.write_string("# author = \"Your Name <you@example.com>\"\n")
  sb.write_string("# source = \"https://github.com/your/repo\"\n")
  sb.write_string("\n")

  // Detect and write dependencies
  let deps = self.detect_dependencies(world)
  if deps.length() > 0 {
    sb.write_string("[dependencies]\n")
    for dep in deps {
      sb.write_string("\"")
      sb.write_string(dep.ns)
      sb.write_string(":")
      sb.write_string(dep.name)
      sb.write_string("\" = \"")
      match dep.version {
        Some(v) => sb.write_string(v)
        None => sb.write_string("*") // Any version
      }
      sb.write_string("\"\n")
    }
    sb.write_string("\n")
  }
  sb.write_string("[overrides]\n")
  sb.write_string("# \"dep:name\" = { path = \"./path/to/wit\" }\n")

  // Output to build/wkg.toml
  let path = match self.opts.out_dir {
    Some(out) => out + "/build/wkg.toml"
    None => "build/wkg.toml"
  }
  self.output.push({ path, content: sb.to_string(), is_stub: true })

  // Generate build justfile
  self.generate_build_justfile(pkg_ns, pkg_name)

  // Generate fetch script if there are dependencies
  if deps.length() > 0 {
    let pkg_refs : Array[@wkg.PackageRef] = deps.map(fn(dep) {
      @wkg.PackageRef::new(dep.ns, dep.name, dep.version)
    })
    let wit_dir = match self.opts.out_dir {
      Some(out) => out + "/wit"
      None => "wit"
    }
    let script = @wkg.generate_fetch_script(pkg_refs, wit_dir)
    let script_path = match self.opts.out_dir {
      Some(out) => out + "/build/fetch-deps.sh"
      None => "build/fetch-deps.sh"
    }
    self.output.push({ path: script_path, content: script, is_stub: true })
  }
}

///|
fn Generator::generate_build_justfile(
  self : Generator,
  _pkg_ns : String,
  pkg_name : String,
) -> Unit {
  let sb = StringBuilder::new()
  sb.write_string("# Build and deploy script for wkg\n")
  sb.write_string("# Usage: just <command>\n\n")

  sb.write_string("default:\n")
  sb.write_string("    @just --list\n\n")

  sb.write_string("# Build the wasm module\n")
  sb.write_string("build:\n")
  sb.write_string("    moon build --target wasm --directory ..\n\n")

  sb.write_string("# Create wasm component from built module\n")
  sb.write_string("component: build\n")
  sb.write_string("    wasm-tools component embed ../../wit/world.wit ../target/wasm/release/build/")
  sb.write_string(self.opts.impl_dir)
  sb.write_string("/")
  sb.write_string(self.opts.impl_dir)
  sb.write_string(".wasm --world ")
  sb.write_string(pkg_name)
  sb.write_string("-world -o component-embedded.wasm\n")
  sb.write_string("    wasm-tools component new component-embedded.wasm -o component.wasm\n")
  sb.write_string("    rm component-embedded.wasm\n\n")

  sb.write_string("# Validate the component\n")
  sb.write_string("validate: component\n")
  sb.write_string("    wasm-tools validate --features component-model component.wasm\n")
  sb.write_string("    wasm-tools component wit component.wasm\n\n")

  sb.write_string("# Publish to wa.dev registry\n")
  sb.write_string("publish: validate\n")
  sb.write_string("    wkg publish component.wasm\n\n")

  sb.write_string("# Clean build artifacts\n")
  sb.write_string("clean:\n")
  sb.write_string("    rm -f component.wasm component-embedded.wasm\n")

  let path = match self.opts.out_dir {
    Some(out) => out + "/build/justfile"
    None => "build/justfile"
  }
  self.output.push({ path, content: sb.to_string(), is_stub: true })

  // Generate .gitignore for build directory
  let gitignore = "component.wasm\ncomponent-embedded.wasm\n"
  let gitignore_path = match self.opts.out_dir {
    Some(out) => out + "/build/.gitignore"
    None => "build/.gitignore"
  }
  self.output.push({ path: gitignore_path, content: gitignore, is_stub: true })
}

///|
/// Generate impl/impl.mbt (user implementation file)
fn Generator::generate_impl(
  self : Generator,
  _id : Int,
  iface_name : String,
  iface : @resolve.Interface,
) -> Unit {
  let sb = StringBuilder::new()
  sb.write_string("// User implementation - edit this file\n")
  sb.write_string("// This file will not be overwritten on regeneration\n\n")

  // Generate struct
  let struct_name = to_pascal_case(iface_name) + "Impl"
  sb.write_string("///|\npub(all) struct ")
  sb.write_string(struct_name)
  sb.write_string(" {}\n\n")

  // Generate trait impl
  let funcs : Array[@resolve.Function] = []
  for _, func in iface.functions {
    funcs.push(func)
  }
  for i, func in funcs {
    sb.write_string("///|\npub impl Exports for ")
    sb.write_string(struct_name)
    sb.write_string(" with ")
    sb.write_string(normalize_func_name(func.name, func.kind))
    sb.write_string("(self")
    for param in func.params {
      let (pname, ptype) = param
      sb.write_string(", ")
      let param_name = if pname == "self" {
        "this"
      } else {
        to_snake_case(pname)
      }
      sb.write_string(param_name)
      sb.write_string(" : ")
      sb.write_string(self.impl_type_name(ptype))
    }
    sb.write_string(") -> ")
    sb.write_string(self.impl_result_type(func.result))
    sb.write_string(" {\n")
    sb.write_string("  let _ = self\n")
    sb.write_string("  // TODO: implement\n")
    sb.write_string("  abort(\"not implemented\")\n")
    sb.write_string("}\n")
    if i < funcs.length() - 1 {
      sb.write_string("\n")
    }
  }
  sb.write_string("\n")

  // Generate init function
  sb.write_string("///|\nfn init {\n")
  sb.write_string("  register(")
  sb.write_string(struct_name)
  sb.write_string("::{})\n")
  sb.write_string("}\n")
  let path = self.impl_path("impl.mbt")
  self.output.push({ path, content: sb.to_string(), is_stub: true })
}

///|
fn Generator::impl_path(self : Generator, filename : String) -> String {
  match self.opts.out_dir {
    Some(out) => out + "/" + self.opts.impl_dir + "/" + filename
    None => self.opts.impl_dir + "/" + filename
  }
}

// Helper: convert snake_case to PascalCase

///|
fn to_pascal_case(s : String) -> String {
  to_camel_case(s)
}

///|
fn Generator::function_trait_sig(
  self : Generator,
  func : @resolve.Function,
) -> String {
  let sb = StringBuilder::new()
  sb.write_string(normalize_func_name(func.name, func.kind))
  sb.write_string("(Self")
  for param in func.params {
    let (pname, ptype) = param
    sb.write_string(", ")
    // Rename 'self' to 'this' to avoid conflict with trait's Self
    let param_name = if pname == "self" { "this" } else { to_snake_case(pname) }
    sb.write_string(param_name)
    sb.write_string(" : ")
    sb.write_string(self.type_name(ptype))
  }
  sb.write_string(") -> ")
  sb.write_string(self.result_type(func.result))
  sb.to_string()
}

///|
fn Generator::param_list(
  self : Generator,
  params : Array[(String, @resolve.Type)],
) -> String {
  let parts : Array[String] = []
  for param in params {
    let (name, ty) = param
    parts.push(name + " : " + self.type_name(ty))
  }
  parts.join(", ")
}

///|
fn Generator::result_type(self : Generator, result : @resolve.Type?) -> String {
  match result {
    None => "Unit"
    Some(ty) => self.type_name(ty)
  }
}

///|
/// Type name for impl files (no prefix, same package)
fn Generator::impl_type_name(self : Generator, ty : @resolve.Type) -> String {
  self.type_name_with_prefix(ty, "")
}

///|
fn Generator::impl_result_type(
  self : Generator,
  result : @resolve.Type?,
) -> String {
  match result {
    None => "Unit"
    Some(ty) => self.impl_type_name(ty)
  }
}

///|
fn Generator::type_name(self : Generator, ty : @resolve.Type) -> String {
  self.type_name_with_prefix(ty, "")
}

///|
/// Type name with optional prefix for custom types (used for stub files)
fn Generator::type_name_with_prefix(
  self : Generator,
  ty : @resolve.Type,
  prefix : String,
) -> String {
  match ty {
    Bool => "Bool"
    U8 => "Byte"
    U16 | U32 => "UInt"
    U64 => "UInt64"
    S8 | S16 | S32 => "Int"
    S64 => "Int64"
    F32 => "Float"
    F64 => "Double"
    Char => "Char"
    String_ => "String"
    Id(id) => self.resolve_type_name_with_prefix(id, prefix)
  }
}

///|
fn Generator::resolve_type_name(self : Generator, id : Int) -> String {
  self.resolve_type_name_with_prefix(id, "")
}

///|
/// Resolve type name with optional prefix for custom types
fn Generator::resolve_type_name_with_prefix(
  self : Generator,
  id : Int,
  prefix : String,
) -> String {
  let typedef = self.resolve.types[id]
  match typedef.kind {
    Record(_) | Variant(_) | Flags(_) | Enum(_) =>
      match typedef.name {
        Some(name) => prefix + to_pascal_case(name)
        None => "Type" + id.to_string()
      }
    List(inner) => "Array[" + self.type_name_with_prefix(inner, prefix) + "]"
    Option(inner) => self.type_name_with_prefix(inner, prefix) + "?"
    Result(ok~, err~) => {
      let ok_type = match ok {
        Some(t) => self.type_name_with_prefix(t, prefix)
        None => "Unit"
      }
      let err_type = match err {
        Some(t) => self.type_name_with_prefix(t, prefix)
        None => "Error"
      }
      "Result[" + ok_type + ", " + err_type + "]"
    }
    Tuple(types) => {
      let parts : Array[String] = types.map(fn(t) {
        self.type_name_with_prefix(t, prefix)
      })
      "(" + parts.join(", ") + ")"
    }
    Alias(inner) => self.type_name_with_prefix(inner, prefix)
    Resource =>
      match typedef.name {
        Some(name) => prefix + to_pascal_case(name)
        None => "Resource" + id.to_string()
      }
    Handle(handle) => {
      let res_id = match handle {
        Own(id) => id
        Borrow(id) => id
      }
      let res_typedef = self.resolve.types[res_id]
      match res_typedef.name {
        Some(name) => prefix + to_pascal_case(name)
        None => "Resource" + res_id.to_string()
      }
    }
  }
}

///|
fn Generator::type_to_ffi(self : Generator, ty : @resolve.Type) -> String {
  match ty {
    Bool => "Bool"
    U8 | U16 | U32 => "Int"
    U64 => "Int64"
    S8 | S16 | S32 => "Int"
    S64 => "Int64"
    F32 => "Float"
    F64 => "Double"
    Char => "Int"
    String_ =>
      if self.opts.use_js_string_builtins {
        "String"
      } else {
        "Int" // pointer
      }
    Id(_) => "Int"
  }
}

///|
fn Generator::result_to_ffi(
  self : Generator,
  result : @resolve.Type?,
) -> String {
  match result {
    None => "Unit"
    Some(ty) => self.type_to_ffi(ty)
  }
}

///|
/// Write export entries for JSON format from ExportInfo array (with leading comma)
fn write_exports_info_json(
  sb : StringBuilder,
  exports : Array[ExportInfo],
  indent : String,
) -> Unit {
  for info in exports {
    sb.write_string(",\n")
    sb.write_string(indent)
    sb.write_string("\"")
    sb.write_string(info.func_name)
    sb.write_string(":")
    sb.write_string(info.wit_name)
    sb.write_string("\"")
  }
}

///|
/// Write export entries for DSL format from ExportInfo array
fn write_exports_info_dsl(
  sb : StringBuilder,
  exports : Array[ExportInfo],
  indent : String,
) -> Unit {
  for info in exports {
    sb.write_string(indent)
    sb.write_string("\"")
    sb.write_string(info.func_name)
    sb.write_string(":")
    sb.write_string(info.wit_name)
    sb.write_string("\",\n")
  }
}

///|
fn Generator::interface_path(
  self : Generator,
  id : Int,
  filename : String,
) -> String {
  let iface = self.resolve.interfaces[id]
  let pkg = iface.pkg.map(fn(pid) { self.resolve.packages[pid] })
  let unnamed = "unnamed"
  let iface_name = iface.name.unwrap_or(unnamed)
  let dir = match pkg {
    Some(p) => {
      let sb = StringBuilder::new()
      sb.write_string(self.opts.gen_dir)
      sb.write_string("/interface/")
      sb.write_string(p.name.ns)
      sb.write_string("/")
      sb.write_string(p.name.name)
      sb.write_string("/")
      sb.write_string(iface_name)
      sb.to_string()
    }
    None => {
      let sb = StringBuilder::new()
      sb.write_string(self.opts.gen_dir)
      sb.write_string("/interface/")
      sb.write_string(iface_name)
      sb.to_string()
    }
  }
  match self.opts.out_dir {
    Some(out) => out + "/" + dir + "/" + filename
    None => dir + "/" + filename
  }
}

///|
fn Generator::generate_type_def(
  self : Generator,
  sb : StringBuilder,
  type_id : Int,
) -> Unit {
  let typedef = self.resolve.types[type_id]
  let type_name = match typedef.name {
    Some(name) => to_pascal_case(name)
    None => return // Anonymous types don't need definitions
  }
  match typedef.kind {
    Record(fields) => {
      sb.write_string("///|\npub struct ")
      sb.write_string(type_name)
      sb.write_string(" {\n")
      for field in fields {
        sb.write_string("  ")
        sb.write_string(to_snake_case(field.name))
        sb.write_string(" : ")
        sb.write_string(self.type_name(field.field_type))
        sb.write_string("\n")
      }
      sb.write_string("} derive(Show, Eq)\n\n")
    }
    Variant(cases) => {
      sb.write_string("///|\npub enum ")
      sb.write_string(type_name)
      sb.write_string(" {\n")
      for case in cases {
        sb.write_string("  ")
        sb.write_string(to_pascal_case(case.name))
        match case.case_type {
          Some(ty) => {
            sb.write_string("(")
            sb.write_string(self.type_name(ty))
            sb.write_string(")")
          }
          None => ()
        }
        sb.write_string("\n")
      }
      sb.write_string("} derive(Show, Eq)\n\n")
    }
    Flags(flags) => {
      // Flags as a struct with bool fields
      sb.write_string("///|\npub struct ")
      sb.write_string(type_name)
      sb.write_string(" {\n")
      for flag in flags {
        sb.write_string("  ")
        sb.write_string(to_snake_case(flag))
        sb.write_string(" : Bool\n")
      }
      sb.write_string("} derive(Show, Eq)\n\n")

      // Generate lift helper
      sb.write_string("///| Lift ")
      sb.write_string(type_name)
      sb.write_string(" from bitmask\n")
      sb.write_string("pub fn ")
      sb.write_string(type_name)
      sb.write_string("::from_bits(bits : Int) -> ")
      sb.write_string(type_name)
      sb.write_string(" {\n")
      sb.write_string("  {\n")
      for i, flag in flags {
        sb.write_string("    ")
        sb.write_string(to_snake_case(flag))
        sb.write_string(": (bits & ")
        sb.write_string((1 << i).to_string())
        sb.write_string(") != 0,\n")
      }
      sb.write_string("  }\n")
      sb.write_string("}\n\n")

      // Generate lower helper
      sb.write_string("///| Lower ")
      sb.write_string(type_name)
      sb.write_string(" to bitmask\n")
      sb.write_string("pub fn ")
      sb.write_string(type_name)
      sb.write_string("::to_bits(self : ")
      sb.write_string(type_name)
      sb.write_string(") -> Int {\n")
      sb.write_string("  let mut bits = 0\n")
      for i, flag in flags {
        sb.write_string("  if self.")
        sb.write_string(to_snake_case(flag))
        sb.write_string(" { bits = bits | ")
        sb.write_string((1 << i).to_string())
        sb.write_string(" }\n")
      }
      sb.write_string("  bits\n")
      sb.write_string("}\n\n")
    }
    Enum(cases) => {
      sb.write_string("///|\npub enum ")
      sb.write_string(type_name)
      sb.write_string(" {\n")
      for case in cases {
        sb.write_string("  ")
        sb.write_string(to_pascal_case(case))
        sb.write_string("\n")
      }
      sb.write_string("} derive(Show, Eq)\n\n")

      // Generate from_ordinal helper
      sb.write_string("///| Lift ")
      sb.write_string(type_name)
      sb.write_string(" from ordinal\n")
      sb.write_string("pub fn ")
      sb.write_string(type_name)
      sb.write_string("::from_ordinal(ordinal : Int) -> ")
      sb.write_string(type_name)
      sb.write_string(" {\n")
      sb.write_string("  match ordinal {\n")
      for i, case in cases {
        sb.write_string("    ")
        sb.write_string(i.to_string())
        sb.write_string(" => ")
        sb.write_string(to_pascal_case(case))
        sb.write_string("\n")
      }
      sb.write_string("    _ => abort(\"invalid enum ordinal\")\n")
      sb.write_string("  }\n")
      sb.write_string("}\n\n")

      // Generate ordinal method
      sb.write_string("///| Lower ")
      sb.write_string(type_name)
      sb.write_string(" to ordinal\n")
      sb.write_string("pub fn ")
      sb.write_string(type_name)
      sb.write_string("::ordinal(self : ")
      sb.write_string(type_name)
      sb.write_string(") -> Int {\n")
      sb.write_string("  match self {\n")
      for i, case in cases {
        sb.write_string("    ")
        sb.write_string(to_pascal_case(case))
        sb.write_string(" => ")
        sb.write_string(i.to_string())
        sb.write_string("\n")
      }
      sb.write_string("  }\n")
      sb.write_string("}\n\n")
    }
    Resource => {
      // Resource is represented as an i32 handle
      sb.write_string("///| Resource handle (i32 index into handle table)\n")
      sb.write_string("pub(all) struct ")
      sb.write_string(type_name)
      sb.write_string("(Int) derive(Show, Eq)\n\n")
    }
    Handle(_) => () // Handle types are inline references to resources
    _ => () // List, Option, Result, Tuple, Alias don't need separate definitions
  }
}

// Helper: convert snake_case to CamelCase

///|
fn to_camel_case(s : String) -> String {
  let sb = StringBuilder::new()
  let mut capitalize_next = true
  for c in s {
    if c == '_' || c == '-' {
      capitalize_next = true
    } else if capitalize_next {
      sb.write_char(c.to_ascii_uppercase())
      capitalize_next = false
    } else {
      sb.write_char(c)
    }
  }
  sb.to_string()
}

// Helper: convert kebab-case to snake_case

///|
fn to_snake_case(s : String) -> String {
  let sb = StringBuilder::new()
  for c in s {
    if c == '-' {
      sb.write_char('_')
    } else {
      sb.write_char(c)
    }
  }
  sb.to_string()
}

///|
/// Normalize WIT function name for MoonBit
/// - `[constructor]blob`  `blob_new`
/// - `[method]blob.size`  `blob_size`
/// - `[static]blob.create`  `blob_create`
/// - `foo-bar`  `foo_bar`
fn normalize_func_name(name : String, kind : @resolve.FunctionKind) -> String {
  match kind {
    Freestanding => to_snake_case(name)
    Constructor(_) => {
      // name is "[constructor]type-name", extract just the type name
      let prefix = "[constructor]"
      if name.has_prefix(prefix) {
        to_snake_case(string_suffix(name, prefix.length())) + "_new"
      } else {
        to_snake_case(name)
      }
    }
    Method(_) => {
      // name is "[method]type-name.method-name"
      let prefix = "[method]"
      if name.has_prefix(prefix) {
        let rest = string_suffix(name, prefix.length())
        // Replace first '.' with '_' and convert to snake_case
        let sb = StringBuilder::new()
        let mut dot_found = false
        for c in rest {
          if c == '.' && not(dot_found) {
            sb.write_char('_')
            dot_found = true
          } else if c == '-' {
            sb.write_char('_')
          } else {
            sb.write_char(c)
          }
        }
        sb.to_string()
      } else {
        to_snake_case(name)
      }
    }
    Static(_) => {
      // name is "[static]type-name.func-name"
      let prefix = "[static]"
      if name.has_prefix(prefix) {
        let rest = string_suffix(name, prefix.length())
        let sb = StringBuilder::new()
        let mut dot_found = false
        for c in rest {
          if c == '.' && not(dot_found) {
            sb.write_char('_')
            dot_found = true
          } else if c == '-' {
            sb.write_char('_')
          } else {
            sb.write_char(c)
          }
        }
        sb.to_string()
      } else {
        to_snake_case(name)
      }
    }
  }
}

///|
/// Get substring from start index to end
fn string_suffix(s : String, start : Int) -> String {
  let sb = StringBuilder::new()
  let chars = s.to_array()
  for i = start; i < chars.length(); i = i + 1 {
    sb.write_char(chars[i])
  }
  sb.to_string()
}

///|
/// Generate impl/moon.pkg.json (is-main with all exports)
fn Generator::generate_impl_pkg(self : Generator) -> Unit {
  if self.exports_info.length() == 0 {
    return
  }

  let sb = StringBuilder::new()
  let cabi_path = self.cabi_import_path()
  match self.opts.pkg_format {
    Json => {
      sb.write_string("{\n")
      sb.write_string("  \"is-main\": true,\n")
      sb.write_string("  \"import\": [\n")
      sb.write_string("    { \"path\": \"")
      sb.write_string(cabi_path)
      sb.write_string("\", \"alias\": \"cabi\" }\n")
      sb.write_string("  ],\n")
      sb.write_string("  \"link\": {\n")
      sb.write_string("    \"wasm\": {\n")
      sb.write_string("      \"exports\": [\n")
      sb.write_string("        \"cabi_realloc:cabi_realloc\"")
      write_exports_info_json(sb, self.exports_info, "        ")
      sb.write_string("\n      ],\n")
      sb.write_string("      \"export-memory-name\": \"memory\"\n")
      sb.write_string("    },\n")
      sb.write_string("    \"wasm-gc\": {\n")
      sb.write_string("      \"exports\": [\n")
      sb.write_string("        \"cabi_realloc:cabi_realloc\"")
      write_exports_info_json(sb, self.exports_info, "        ")
      sb.write_string("\n      ],\n")
      sb.write_string("      \"export-memory-name\": \"memory\"")
      if self.opts.use_js_string_builtins {
        sb.write_string(",\n      \"use-js-builtin-string\": true\n")
      } else {
        sb.write_string("\n")
      }
      sb.write_string("    }\n")
      sb.write_string("  }\n")
      sb.write_string("}\n")
    }
    Dsl => {
      sb.write_string("import(\n")
      sb.write_string("  \"")
      sb.write_string(cabi_path)
      sb.write_string("\" as cabi,\n")
      sb.write_string(")\n\n")
      sb.write_string("options(\n")
      sb.write_string("  is_main: true,\n")
      sb.write_string("  link: {\n")
      sb.write_string("    wasm: {\n")
      sb.write_string("      exports: [\n")
      sb.write_string("        \"cabi_realloc:cabi_realloc\",\n")
      write_exports_info_dsl(sb, self.exports_info, "        ")
      sb.write_string("      ],\n")
      sb.write_string("      export_memory_name: \"memory\",\n")
      sb.write_string("    },\n")
      sb.write_string("    wasm_gc: {\n")
      sb.write_string("      exports: [\n")
      sb.write_string("        \"cabi_realloc:cabi_realloc\",\n")
      write_exports_info_dsl(sb, self.exports_info, "        ")
      sb.write_string("      ],\n")
      sb.write_string("      export_memory_name: \"memory\",\n")
      if self.opts.use_js_string_builtins {
        sb.write_string("      use_js_builtin_string: true,\n")
      }
      sb.write_string("    },\n")
      sb.write_string("  },\n")
      sb.write_string(")\n")
    }
  }
  let filename = match self.opts.pkg_format {
    Json => "moon.pkg.json"
    Dsl => "moon.pkg"
  }
  let path = self.impl_path(filename)
  // is_stub: true so user's custom imports are preserved
  self.output.push({ path, content: sb.to_string(), is_stub: true })
}
